/*
 * generated by Xtext 2.32.0
 */
/*
 * Copyright (c) 2022, 2023 Epistimis LLC (http://www.epistimis.com).
 */
package com.epistimis.uddl.query.services;

import com.google.inject.Inject;
import com.google.inject.Singleton;
import java.util.List;
import org.eclipse.xtext.Alternatives;
import org.eclipse.xtext.Assignment;
import org.eclipse.xtext.Grammar;
import org.eclipse.xtext.GrammarUtil;
import org.eclipse.xtext.Group;
import org.eclipse.xtext.Keyword;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.RuleCall;
import org.eclipse.xtext.TerminalRule;
import org.eclipse.xtext.common.services.TerminalsGrammarAccess;
import org.eclipse.xtext.service.AbstractElementFinder;
import org.eclipse.xtext.service.GrammarProvider;

@Singleton
public class QueryGrammarAccess extends AbstractElementFinder.AbstractGrammarElementFinder {
	
	public class QuerySpecificationElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.QuerySpecification");
		private final RuleCall cQueryStatementParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		// * https://stackoverflow.com/questions/30889847/match-string-in-xtext-regardless-of-upper-lower-case (second, more recent response) indicates how
		// * to get case insensitive keywords. But this means that they must be keywords, not Terminals.
		// * TODO: replace Replace grammar terminals keywords with literal keywords. What impact does this have on Langium?
		// *
		// * BooleanPredicate is not LL. See book for how to handle this. This modification is because the original grammar is ANTLR 4, but XText only
		// * supports ANTLR 3.
		// */
		///**
		//A QuerySpecification represents a Query in the Data Model.
		//*/
		//QuerySpecification : QueryStatement ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryStatement
		public RuleCall getQueryStatementParserRuleCall() { return cQueryStatementParserRuleCall; }
	}
	public class QueryStatementElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.QueryStatement");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cSelectKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cQualifierAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQualifierSetQualifierParserRuleCall_1_0 = (RuleCall)cQualifierAssignment_1.eContents().get(0);
		private final Assignment cProjectedCharacteristicListAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cProjectedCharacteristicListProjectedCharacteristicListParserRuleCall_2_0 = (RuleCall)cProjectedCharacteristicListAssignment_2.eContents().get(0);
		private final Assignment cSelectedEntityExpressionAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSelectedEntityExpressionSelectedEntityExpressionParserRuleCall_3_0 = (RuleCall)cSelectedEntityExpressionAssignment_3.eContents().get(0);
		private final Keyword cSemicolonKeyword_4 = (Keyword)cGroup.eContents().get(4);
		
		///**
		//A QueryStatement is the expression of a Query, which is a declaration of a set of data in terms of a set of Entities and their
		//Characteristics. The SelectedEntityExpression defines the context for a QueryStatement's data set as a set of related Entities
		//and optionally a set of conditions expressed over their Characteristics that are true for all data in the data set.
		//The ProjectedCharacteristicList identifies the specific Characteristics that are the elements of the QueryStatement's data set.
		//The SetQualifier DISTINCT, if specified, indicates that instances of data in the data set are not duplicated. Otherwise,
		//they may be duplicated.
		//*
		//* Optionally followed by a semicolon
		//*
		//*/
		////QueryStatement : KW_SELECT , [ SetQualifier ] , ProjectedCharacteristicList , SelectedEntityExpression ;
		//QueryStatement : 'select' ( qualifier=SetQualifier )? projectedCharacteristicList=ProjectedCharacteristicList
		//    selectedEntityExpression=SelectedEntityExpression ';'?
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//'select' ( qualifier=SetQualifier )? projectedCharacteristicList=ProjectedCharacteristicList
		//   selectedEntityExpression=SelectedEntityExpression ';'?
		public Group getGroup() { return cGroup; }
		
		//'select'
		public Keyword getSelectKeyword_0() { return cSelectKeyword_0; }
		
		//( qualifier=SetQualifier )?
		public Assignment getQualifierAssignment_1() { return cQualifierAssignment_1; }
		
		//SetQualifier
		public RuleCall getQualifierSetQualifierParserRuleCall_1_0() { return cQualifierSetQualifierParserRuleCall_1_0; }
		
		//projectedCharacteristicList=ProjectedCharacteristicList
		public Assignment getProjectedCharacteristicListAssignment_2() { return cProjectedCharacteristicListAssignment_2; }
		
		//ProjectedCharacteristicList
		public RuleCall getProjectedCharacteristicListProjectedCharacteristicListParserRuleCall_2_0() { return cProjectedCharacteristicListProjectedCharacteristicListParserRuleCall_2_0; }
		
		//selectedEntityExpression=SelectedEntityExpression
		public Assignment getSelectedEntityExpressionAssignment_3() { return cSelectedEntityExpressionAssignment_3; }
		
		//SelectedEntityExpression
		public RuleCall getSelectedEntityExpressionSelectedEntityExpressionParserRuleCall_3_0() { return cSelectedEntityExpressionSelectedEntityExpressionParserRuleCall_3_0; }
		
		//';'?
		public Keyword getSemicolonKeyword_4() { return cSemicolonKeyword_4; }
	}
	public class SetQualifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SetQualifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_DISTINCTTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_ALLTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A SetQualifier indicates whether instances of data in a set are unique (KW_DISTINCT) or not (KW_ALL).
		//*/
		//SetQualifier : KW_DISTINCT | KW_ALL ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_DISTINCT | KW_ALL
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//KW_DISTINCT
		public RuleCall getKW_DISTINCTTerminalRuleCall_0() { return cKW_DISTINCTTerminalRuleCall_0; }
		
		//KW_ALL
		public RuleCall getKW_ALLTerminalRuleCall_1() { return cKW_ALLTerminalRuleCall_1; }
	}
	public class ProjectedCharacteristicListElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ProjectedCharacteristicList");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final Assignment cAllAssignment_0 = (Assignment)cAlternatives.eContents().get(0);
		private final RuleCall cAllALL_CHARACTERISTICSTerminalRuleCall_0_0 = (RuleCall)cAllAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cAlternatives.eContents().get(1);
		private final Assignment cCharacteristicAssignment_1_0 = (Assignment)cGroup_1.eContents().get(0);
		private final RuleCall cCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_0_0 = (RuleCall)cCharacteristicAssignment_1_0.eContents().get(0);
		private final Group cGroup_1_1 = (Group)cGroup_1.eContents().get(1);
		private final RuleCall cCOMMATerminalRuleCall_1_1_0 = (RuleCall)cGroup_1_1.eContents().get(0);
		private final Assignment cCharacteristicAssignment_1_1_1 = (Assignment)cGroup_1_1.eContents().get(1);
		private final RuleCall cCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_1_1_0 = (RuleCall)cCharacteristicAssignment_1_1_1.eContents().get(0);
		
		///**
		//A ProjectedCharacteristicList defines the set of Characteristics in a QueryStatement. ALL_CHARACTERISTICS indicates that every
		//Characteristic of every SelectedEntity is included. Otherwise, the Characteristics are those specified by the
		//projected_characteristic_expressions. In both cases, only those Characteristics whose types are not Entities are included.
		//*/
		//ProjectedCharacteristicList : all=ALL_CHARACTERISTICS | characteristic+=ProjectedCharacteristicExpression  ( COMMA  characteristic+=ProjectedCharacteristicExpression )* ;
		@Override public ParserRule getRule() { return rule; }
		
		//all=ALL_CHARACTERISTICS | characteristic+=ProjectedCharacteristicExpression  ( COMMA  characteristic+=ProjectedCharacteristicExpression )*
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//all=ALL_CHARACTERISTICS
		public Assignment getAllAssignment_0() { return cAllAssignment_0; }
		
		//ALL_CHARACTERISTICS
		public RuleCall getAllALL_CHARACTERISTICSTerminalRuleCall_0_0() { return cAllALL_CHARACTERISTICSTerminalRuleCall_0_0; }
		
		//characteristic+=ProjectedCharacteristicExpression  ( COMMA  characteristic+=ProjectedCharacteristicExpression )*
		public Group getGroup_1() { return cGroup_1; }
		
		//characteristic+=ProjectedCharacteristicExpression
		public Assignment getCharacteristicAssignment_1_0() { return cCharacteristicAssignment_1_0; }
		
		//ProjectedCharacteristicExpression
		public RuleCall getCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_0_0() { return cCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_0_0; }
		
		//( COMMA  characteristic+=ProjectedCharacteristicExpression )*
		public Group getGroup_1_1() { return cGroup_1_1; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_1_1_0() { return cCOMMATerminalRuleCall_1_1_0; }
		
		//characteristic+=ProjectedCharacteristicExpression
		public Assignment getCharacteristicAssignment_1_1_1() { return cCharacteristicAssignment_1_1_1; }
		
		//ProjectedCharacteristicExpression
		public RuleCall getCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_1_1_0() { return cCharacteristicProjectedCharacteristicExpressionParserRuleCall_1_1_1_0; }
	}
	public class ProjectedCharacteristicExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ProjectedCharacteristicExpression");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelectedEntityCharacteristicWildcardReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExplicitSelectedEntityCharacteristicReferenceParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A ProjectedCharacteristicExpression represents one or more Characteristics of a specific Entity.
		//*/
		//ProjectedCharacteristicExpression : SelectedEntityCharacteristicWildcardReference | ExplicitSelectedEntityCharacteristicReference ;
		@Override public ParserRule getRule() { return rule; }
		
		//SelectedEntityCharacteristicWildcardReference | ExplicitSelectedEntityCharacteristicReference
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SelectedEntityCharacteristicWildcardReference
		public RuleCall getSelectedEntityCharacteristicWildcardReferenceParserRuleCall_0() { return cSelectedEntityCharacteristicWildcardReferenceParserRuleCall_0; }
		
		//ExplicitSelectedEntityCharacteristicReference
		public RuleCall getExplicitSelectedEntityCharacteristicReferenceParserRuleCall_1() { return cExplicitSelectedEntityCharacteristicReferenceParserRuleCall_1; }
	}
	public class SelectedEntityCharacteristicWildcardReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntityCharacteristicWildcardReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSelectedEntityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSelectedEntitySelectedEntityReferenceParserRuleCall_0_0 = (RuleCall)cSelectedEntityAssignment_0.eContents().get(0);
		private final RuleCall cPERIODTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final RuleCall cALL_CHARACTERISTICSTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		///**
		//A SelectedEntityCharacteristicWildcardReference is a shorthand notation indicating "every Characteristic of SelectedEntityReference".
		//*/
		//SelectedEntityCharacteristicWildcardReference : selectedEntity=SelectedEntityReference  PERIOD  ALL_CHARACTERISTICS ;
		@Override public ParserRule getRule() { return rule; }
		
		//selectedEntity=SelectedEntityReference  PERIOD  ALL_CHARACTERISTICS
		public Group getGroup() { return cGroup; }
		
		//selectedEntity=SelectedEntityReference
		public Assignment getSelectedEntityAssignment_0() { return cSelectedEntityAssignment_0; }
		
		//SelectedEntityReference
		public RuleCall getSelectedEntitySelectedEntityReferenceParserRuleCall_0_0() { return cSelectedEntitySelectedEntityReferenceParserRuleCall_0_0; }
		
		//PERIOD
		public RuleCall getPERIODTerminalRuleCall_1() { return cPERIODTerminalRuleCall_1; }
		
		//ALL_CHARACTERISTICS
		public RuleCall getALL_CHARACTERISTICSTerminalRuleCall_2() { return cALL_CHARACTERISTICSTerminalRuleCall_2; }
	}
	public class ExplicitSelectedEntityCharacteristicReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ExplicitSelectedEntityCharacteristicReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSelectedEntityCharacteristicReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSelectedEntityCharacteristicReferenceSelectedEntityCharacteristicReferenceParserRuleCall_0_0 = (RuleCall)cSelectedEntityCharacteristicReferenceAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_ASTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cProjectedCharacteristicAliasAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cProjectedCharacteristicAliasProjectedCharacteristicAliasParserRuleCall_1_1_0 = (RuleCall)cProjectedCharacteristicAliasAssignment_1_1.eContents().get(0);
		
		///**
		//An ExplicitSelectedEntityCharacteristicReference represents one Characteristic of one Entity. ProjectedCharacteristicAlias specifies an optional alias for the Characteristic for use elsewhere in a QueryStatement.
		//*/
		//ExplicitSelectedEntityCharacteristicReference : selectedEntityCharacteristicReference=SelectedEntityCharacteristicReference  ( ( KW_AS )?  projectedCharacteristicAlias=ProjectedCharacteristicAlias )? ;
		@Override public ParserRule getRule() { return rule; }
		
		//selectedEntityCharacteristicReference=SelectedEntityCharacteristicReference  ( ( KW_AS )?  projectedCharacteristicAlias=ProjectedCharacteristicAlias )?
		public Group getGroup() { return cGroup; }
		
		//selectedEntityCharacteristicReference=SelectedEntityCharacteristicReference
		public Assignment getSelectedEntityCharacteristicReferenceAssignment_0() { return cSelectedEntityCharacteristicReferenceAssignment_0; }
		
		//SelectedEntityCharacteristicReference
		public RuleCall getSelectedEntityCharacteristicReferenceSelectedEntityCharacteristicReferenceParserRuleCall_0_0() { return cSelectedEntityCharacteristicReferenceSelectedEntityCharacteristicReferenceParserRuleCall_0_0; }
		
		//( ( KW_AS )?  projectedCharacteristicAlias=ProjectedCharacteristicAlias )?
		public Group getGroup_1() { return cGroup_1; }
		
		//( KW_AS )?
		public RuleCall getKW_ASTerminalRuleCall_1_0() { return cKW_ASTerminalRuleCall_1_0; }
		
		//projectedCharacteristicAlias=ProjectedCharacteristicAlias
		public Assignment getProjectedCharacteristicAliasAssignment_1_1() { return cProjectedCharacteristicAliasAssignment_1_1; }
		
		//ProjectedCharacteristicAlias
		public RuleCall getProjectedCharacteristicAliasProjectedCharacteristicAliasParserRuleCall_1_1_0() { return cProjectedCharacteristicAliasProjectedCharacteristicAliasParserRuleCall_1_1_0; }
	}
	public class SelectedEntityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFromAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFromFromClauseParserRuleCall_0_0 = (RuleCall)cFromAssignment_0.eContents().get(0);
		private final Assignment cWhereAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cWhereWhereClauseParserRuleCall_1_0 = (RuleCall)cWhereAssignment_1.eContents().get(0);
		private final Assignment cOrderByAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOrderByOrderByClauseParserRuleCall_2_0 = (RuleCall)cOrderByAssignment_2.eContents().get(0);
		
		///**
		//A SelectedEntityExpression defines the context for a QueryStatement's data set as a set of related Entities (using the FromClause). It may also specify a set of conditions expressed over Characteristics of those Entities that are true for all data in the data set (using a WhereClause) and specify how data in the data set is ordered (using an OrderByClause).
		//*/
		//SelectedEntityExpression : from=FromClause  ( where=WhereClause )?  ( orderBy=OrderByClause )? ;
		@Override public ParserRule getRule() { return rule; }
		
		//from=FromClause  ( where=WhereClause )?  ( orderBy=OrderByClause )?
		public Group getGroup() { return cGroup; }
		
		//from=FromClause
		public Assignment getFromAssignment_0() { return cFromAssignment_0; }
		
		//FromClause
		public RuleCall getFromFromClauseParserRuleCall_0_0() { return cFromFromClauseParserRuleCall_0_0; }
		
		//( where=WhereClause )?
		public Assignment getWhereAssignment_1() { return cWhereAssignment_1; }
		
		//WhereClause
		public RuleCall getWhereWhereClauseParserRuleCall_1_0() { return cWhereWhereClauseParserRuleCall_1_0; }
		
		//( orderBy=OrderByClause )?
		public Assignment getOrderByAssignment_2() { return cOrderByAssignment_2; }
		
		//OrderByClause
		public RuleCall getOrderByOrderByClauseParserRuleCall_2_0() { return cOrderByOrderByClauseParserRuleCall_2_0; }
	}
	public class FromClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.FromClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Keyword cFromKeyword_0 = (Keyword)cGroup.eContents().get(0);
		private final Assignment cEntityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEntityEntityExpressionParserRuleCall_1_0 = (RuleCall)cEntityAssignment_1.eContents().get(0);
		
		///**
		//A FromClause identifies a set of related Entities via EntityExpression.
		//*/
		//FromClause : 'from'  entity=EntityExpression ;
		@Override public ParserRule getRule() { return rule; }
		
		//'from'  entity=EntityExpression
		public Group getGroup() { return cGroup; }
		
		//'from'
		public Keyword getFromKeyword_0() { return cFromKeyword_0; }
		
		//entity=EntityExpression
		public Assignment getEntityAssignment_1() { return cEntityAssignment_1; }
		
		//EntityExpression
		public RuleCall getEntityEntityExpressionParserRuleCall_1_0() { return cEntityEntityExpressionParserRuleCall_1_0; }
	}
	public class EntityExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EntityExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSelectedEntityAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSelectedEntitySelectedEntityParserRuleCall_0_0 = (RuleCall)cSelectedEntityAssignment_0.eContents().get(0);
		private final Assignment cEjeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cEjeEntityJoinExpressionParserRuleCall_1_0 = (RuleCall)cEjeAssignment_1.eContents().get(0);
		
		///**
		//An EntityExpression identifies a set of Entities and a set of relationships between those Entities. The set of Entities are the selected_entitys in the EntityExpression. The set of relationships are identified by the entity_type_characteristic_equivalence_expressions in the EntityExpression.
		//*/
		////EntityExpression : selectedEntity=SelectedEntity , { EntityJoinExpression } ;
		//EntityExpression : selectedEntity=SelectedEntity  (eje+=EntityJoinExpression)*  ;
		@Override public ParserRule getRule() { return rule; }
		
		//selectedEntity=SelectedEntity  (eje+=EntityJoinExpression)*
		public Group getGroup() { return cGroup; }
		
		//selectedEntity=SelectedEntity
		public Assignment getSelectedEntityAssignment_0() { return cSelectedEntityAssignment_0; }
		
		//SelectedEntity
		public RuleCall getSelectedEntitySelectedEntityParserRuleCall_0_0() { return cSelectedEntitySelectedEntityParserRuleCall_0_0; }
		
		//(eje+=EntityJoinExpression)*
		public Assignment getEjeAssignment_1() { return cEjeAssignment_1; }
		
		//EntityJoinExpression
		public RuleCall getEjeEntityJoinExpressionParserRuleCall_1_0() { return cEjeEntityJoinExpressionParserRuleCall_1_0; }
	}
	public class SelectedEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntity");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEntityTypeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEntityTypeEntityTypeReferenceParserRuleCall_0_0 = (RuleCall)cEntityTypeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_ASTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSelectedEntityAliasAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSelectedEntityAliasSelectedEntityAliasParserRuleCall_1_1_0 = (RuleCall)cSelectedEntityAliasAssignment_1_1.eContents().get(0);
		
		///**
		//A SelectedEntity is the Entity whose name is EntityTypeReference. SelectedEntityAlias specifies an alias for the Entity for use elsewhere in a QueryStatement.
		//*/
		//SelectedEntity : entityType=EntityTypeReference  ( ( KW_AS )?  selectedEntityAlias=SelectedEntityAlias )? ;
		@Override public ParserRule getRule() { return rule; }
		
		//entityType=EntityTypeReference  ( ( KW_AS )?  selectedEntityAlias=SelectedEntityAlias )?
		public Group getGroup() { return cGroup; }
		
		//entityType=EntityTypeReference
		public Assignment getEntityTypeAssignment_0() { return cEntityTypeAssignment_0; }
		
		//EntityTypeReference
		public RuleCall getEntityTypeEntityTypeReferenceParserRuleCall_0_0() { return cEntityTypeEntityTypeReferenceParserRuleCall_0_0; }
		
		//( ( KW_AS )?  selectedEntityAlias=SelectedEntityAlias )?
		public Group getGroup_1() { return cGroup_1; }
		
		//( KW_AS )?
		public RuleCall getKW_ASTerminalRuleCall_1_0() { return cKW_ASTerminalRuleCall_1_0; }
		
		//selectedEntityAlias=SelectedEntityAlias
		public Assignment getSelectedEntityAliasAssignment_1_1() { return cSelectedEntityAliasAssignment_1_1; }
		
		//SelectedEntityAlias
		public RuleCall getSelectedEntityAliasSelectedEntityAliasParserRuleCall_1_1_0() { return cSelectedEntityAliasSelectedEntityAliasParserRuleCall_1_1_0; }
	}
	public class EntityJoinExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EntityJoinExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_JOINTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cJoinEntityAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cJoinEntityJoinEntityParserRuleCall_1_0 = (RuleCall)cJoinEntityAssignment_1.eContents().get(0);
		private final RuleCall cKW_ONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cEntityJoinCriteriaAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cEntityJoinCriteriaEntityJoinCriteriaParserRuleCall_3_0 = (RuleCall)cEntityJoinCriteriaAssignment_3.eContents().get(0);
		
		///**
		//    An EntityJoinExpression identifies an Entity (JoinEntity) and one or more relationships between it and other selected_entitys in the EntityExpression. Each relationship is identified with an EntityTypeCharacteristicEquivalenceExpression whose SelectedEntityCharacteristicReference is either a Characteristic of JoinEntity whose type is another SelectedEntity, or is a Characteristic of another SelectedEntity whose type is JoinEntity.
		//*/
		//EntityJoinExpression : KW_JOIN  joinEntity=JoinEntity  KW_ON  entityJoinCriteria=EntityJoinCriteria ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_JOIN  joinEntity=JoinEntity  KW_ON  entityJoinCriteria=EntityJoinCriteria
		public Group getGroup() { return cGroup; }
		
		//KW_JOIN
		public RuleCall getKW_JOINTerminalRuleCall_0() { return cKW_JOINTerminalRuleCall_0; }
		
		//joinEntity=JoinEntity
		public Assignment getJoinEntityAssignment_1() { return cJoinEntityAssignment_1; }
		
		//JoinEntity
		public RuleCall getJoinEntityJoinEntityParserRuleCall_1_0() { return cJoinEntityJoinEntityParserRuleCall_1_0; }
		
		//KW_ON
		public RuleCall getKW_ONTerminalRuleCall_2() { return cKW_ONTerminalRuleCall_2; }
		
		//entityJoinCriteria=EntityJoinCriteria
		public Assignment getEntityJoinCriteriaAssignment_3() { return cEntityJoinCriteriaAssignment_3; }
		
		//EntityJoinCriteria
		public RuleCall getEntityJoinCriteriaEntityJoinCriteriaParserRuleCall_3_0() { return cEntityJoinCriteriaEntityJoinCriteriaParserRuleCall_3_0; }
	}
	public class JoinEntityElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.JoinEntity");
		private final RuleCall cSelectedEntityParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A JoinEntity is a SelectedEntity in an EntityJoinExpression.
		//*/
		//JoinEntity : SelectedEntity ;
		@Override public ParserRule getRule() { return rule; }
		
		//SelectedEntity
		public RuleCall getSelectedEntityParserRuleCall() { return cSelectedEntityParserRuleCall; }
	}
	public class EntityJoinCriteriaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EntityJoinCriteria");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cEtceeAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_0_0 = (RuleCall)cEtceeAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_ANDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cEtceeAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_1_1_0 = (RuleCall)cEtceeAssignment_1_1.eContents().get(0);
		
		///**
		//An EntityJoinCriteria identifies one or more relationships between two or more selected_entitys in the EntityExpression. Each EntityTypeCharacteristicEquivalenceExpression identifies a relationship between two selected_entitys.
		//*/
		//EntityJoinCriteria : etcee+=EntityTypeCharacteristicEquivalenceExpression  ( KW_AND  etcee+=EntityTypeCharacteristicEquivalenceExpression )* ;
		@Override public ParserRule getRule() { return rule; }
		
		//etcee+=EntityTypeCharacteristicEquivalenceExpression  ( KW_AND  etcee+=EntityTypeCharacteristicEquivalenceExpression )*
		public Group getGroup() { return cGroup; }
		
		//etcee+=EntityTypeCharacteristicEquivalenceExpression
		public Assignment getEtceeAssignment_0() { return cEtceeAssignment_0; }
		
		//EntityTypeCharacteristicEquivalenceExpression
		public RuleCall getEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_0_0() { return cEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_0_0; }
		
		//( KW_AND  etcee+=EntityTypeCharacteristicEquivalenceExpression )*
		public Group getGroup_1() { return cGroup_1; }
		
		//KW_AND
		public RuleCall getKW_ANDTerminalRuleCall_1_0() { return cKW_ANDTerminalRuleCall_1_0; }
		
		//etcee+=EntityTypeCharacteristicEquivalenceExpression
		public Assignment getEtceeAssignment_1_1() { return cEtceeAssignment_1_1; }
		
		//EntityTypeCharacteristicEquivalenceExpression
		public RuleCall getEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_1_1_0() { return cEtceeEntityTypeCharacteristicEquivalenceExpressionParserRuleCall_1_1_0; }
	}
	public class EntityTypeCharacteristicEquivalenceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EntityTypeCharacteristicEquivalenceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSecrAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSecrSelectedEntityCharacteristicReferenceParserRuleCall_0_0 = (RuleCall)cSecrAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cEQUALS_OPERATORTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cSelectedEntityAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cSelectedEntitySelectedEntityReferenceParserRuleCall_1_1_0 = (RuleCall)cSelectedEntityAssignment_1_1.eContents().get(0);
		
		///**
		//An EntityTypeCharacteristicEquivalenceExpression identifies a relationship between two selected_entitys. SelectedEntityCharacteristicReference is a Characteristic of one SelectedEntity whose type is the another SelectedEntity in the EntityExpression. A SelectedEntityReference is used to identify a specific SelectedEntity should there be more than one SelectedEntity whose type is that Characteristic's type.
		//*/
		//EntityTypeCharacteristicEquivalenceExpression : secr=SelectedEntityCharacteristicReference  ( EQUALS_OPERATOR  selectedEntity=SelectedEntityReference )? ;
		@Override public ParserRule getRule() { return rule; }
		
		//secr=SelectedEntityCharacteristicReference  ( EQUALS_OPERATOR  selectedEntity=SelectedEntityReference )?
		public Group getGroup() { return cGroup; }
		
		//secr=SelectedEntityCharacteristicReference
		public Assignment getSecrAssignment_0() { return cSecrAssignment_0; }
		
		//SelectedEntityCharacteristicReference
		public RuleCall getSecrSelectedEntityCharacteristicReferenceParserRuleCall_0_0() { return cSecrSelectedEntityCharacteristicReferenceParserRuleCall_0_0; }
		
		//( EQUALS_OPERATOR  selectedEntity=SelectedEntityReference )?
		public Group getGroup_1() { return cGroup_1; }
		
		//EQUALS_OPERATOR
		public RuleCall getEQUALS_OPERATORTerminalRuleCall_1_0() { return cEQUALS_OPERATORTerminalRuleCall_1_0; }
		
		//selectedEntity=SelectedEntityReference
		public Assignment getSelectedEntityAssignment_1_1() { return cSelectedEntityAssignment_1_1; }
		
		//SelectedEntityReference
		public RuleCall getSelectedEntitySelectedEntityReferenceParserRuleCall_1_1_0() { return cSelectedEntitySelectedEntityReferenceParserRuleCall_1_1_0; }
	}
	public class SelectedEntityCharacteristicReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntityCharacteristicReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Group cGroup_0 = (Group)cGroup.eContents().get(0);
		private final Assignment cSelectedEntityAssignment_0_0 = (Assignment)cGroup_0.eContents().get(0);
		private final RuleCall cSelectedEntitySelectedEntityReferenceParserRuleCall_0_0_0 = (RuleCall)cSelectedEntityAssignment_0_0.eContents().get(0);
		private final RuleCall cPERIODTerminalRuleCall_0_1 = (RuleCall)cGroup_0.eContents().get(1);
		private final Assignment cCharacteristicAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCharacteristicCharacteristicReferenceParserRuleCall_1_0 = (RuleCall)cCharacteristicAssignment_1.eContents().get(0);
		
		///**
		//A SelectedEntityCharacteristicReference is a SelectedEntity's Characteristic specified by CharacteristicReference.
		//A SelectedEntityReference is used to identify a specific SelectedEntity should there be more than one Characteristic
		//whose name is CharacteristicReference.
		//*/
		//SelectedEntityCharacteristicReference : ( selectedEntity=SelectedEntityReference  PERIOD )?  characteristic=CharacteristicReference ;
		@Override public ParserRule getRule() { return rule; }
		
		//( selectedEntity=SelectedEntityReference  PERIOD )?  characteristic=CharacteristicReference
		public Group getGroup() { return cGroup; }
		
		//( selectedEntity=SelectedEntityReference  PERIOD )?
		public Group getGroup_0() { return cGroup_0; }
		
		//selectedEntity=SelectedEntityReference
		public Assignment getSelectedEntityAssignment_0_0() { return cSelectedEntityAssignment_0_0; }
		
		//SelectedEntityReference
		public RuleCall getSelectedEntitySelectedEntityReferenceParserRuleCall_0_0_0() { return cSelectedEntitySelectedEntityReferenceParserRuleCall_0_0_0; }
		
		//PERIOD
		public RuleCall getPERIODTerminalRuleCall_0_1() { return cPERIODTerminalRuleCall_0_1; }
		
		//characteristic=CharacteristicReference
		public Assignment getCharacteristicAssignment_1() { return cCharacteristicAssignment_1; }
		
		//CharacteristicReference
		public RuleCall getCharacteristicCharacteristicReferenceParserRuleCall_1_0() { return cCharacteristicCharacteristicReferenceParserRuleCall_1_0; }
	}
	public class SelectedEntityReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntityReference");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A SelectedEntityReference is a reference by name to a SelectedEntity, where QueryIdentifier is either a SelectedEntity's
		//EntityTypeReference or its SelectedEntityAlias.
		//*/
		//SelectedEntityReference : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class WhereClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.WhereClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_WHERETerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cCriteriaAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCriteriaCriteriaParserRuleCall_1_0 = (RuleCall)cCriteriaAssignment_1.eContents().get(0);
		
		///**
		//A WhereClause specifies a set of conditions that are true for all data in the QueryStatement's data set.
		//*/
		//WhereClause : KW_WHERE  criteria=Criteria ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_WHERE  criteria=Criteria
		public Group getGroup() { return cGroup; }
		
		//KW_WHERE
		public RuleCall getKW_WHERETerminalRuleCall_0() { return cKW_WHERETerminalRuleCall_0; }
		
		//criteria=Criteria
		public Assignment getCriteriaAssignment_1() { return cCriteriaAssignment_1; }
		
		//Criteria
		public RuleCall getCriteriaCriteriaParserRuleCall_1_0() { return cCriteriaCriteriaParserRuleCall_1_0; }
	}
	public class CriteriaElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.Criteria");
		private final RuleCall cBooleanExpressionParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A Criteria specifies a set of conditions expressed over Characteristics of selected_entitys via BooleanExpression.
		//*/
		//Criteria : BooleanExpression ;
		@Override public ParserRule getRule() { return rule; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall() { return cBooleanExpressionParserRuleCall; }
	}
	public class OrderByClauseElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.OrderByClause");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_ORDERTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final RuleCall cKW_BYTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cOrderingExpressionAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cOrderingExpressionOrderingExpressionParserRuleCall_2_0 = (RuleCall)cOrderingExpressionAssignment_2.eContents().get(0);
		private final Group cGroup_3 = (Group)cGroup.eContents().get(3);
		private final RuleCall cCOMMATerminalRuleCall_3_0 = (RuleCall)cGroup_3.eContents().get(0);
		private final Assignment cOrderingExpressionAssignment_3_1 = (Assignment)cGroup_3.eContents().get(1);
		private final RuleCall cOrderingExpressionOrderingExpressionParserRuleCall_3_1_0 = (RuleCall)cOrderingExpressionAssignment_3_1.eContents().get(0);
		
		///**
		//An OrderByClause specifies how data in the QueryStatement's data set is ordered. The data set is initially ordered by the first OrderingExpression's ProjectedCharacteristicReference. Each additional OrderingExpression further orders the data set.
		//*/
		//OrderByClause : KW_ORDER  KW_BY  orderingExpression+=OrderingExpression  ( COMMA  orderingExpression+=OrderingExpression )* ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_ORDER  KW_BY  orderingExpression+=OrderingExpression  ( COMMA  orderingExpression+=OrderingExpression )*
		public Group getGroup() { return cGroup; }
		
		//KW_ORDER
		public RuleCall getKW_ORDERTerminalRuleCall_0() { return cKW_ORDERTerminalRuleCall_0; }
		
		//KW_BY
		public RuleCall getKW_BYTerminalRuleCall_1() { return cKW_BYTerminalRuleCall_1; }
		
		//orderingExpression+=OrderingExpression
		public Assignment getOrderingExpressionAssignment_2() { return cOrderingExpressionAssignment_2; }
		
		//OrderingExpression
		public RuleCall getOrderingExpressionOrderingExpressionParserRuleCall_2_0() { return cOrderingExpressionOrderingExpressionParserRuleCall_2_0; }
		
		//( COMMA  orderingExpression+=OrderingExpression )*
		public Group getGroup_3() { return cGroup_3; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_3_0() { return cCOMMATerminalRuleCall_3_0; }
		
		//orderingExpression+=OrderingExpression
		public Assignment getOrderingExpressionAssignment_3_1() { return cOrderingExpressionAssignment_3_1; }
		
		//OrderingExpression
		public RuleCall getOrderingExpressionOrderingExpressionParserRuleCall_3_1_0() { return cOrderingExpressionOrderingExpressionParserRuleCall_3_1_0; }
	}
	public class OrderingExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.OrderingExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cCharacteristicAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cCharacteristicProjectedCharacteristicReferenceParserRuleCall_0_0 = (RuleCall)cCharacteristicAssignment_0.eContents().get(0);
		private final Assignment cOrderingTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOrderingTypeOrderingTypeParserRuleCall_1_0 = (RuleCall)cOrderingTypeAssignment_1.eContents().get(0);
		
		///**
		//An OrderingExpression specifies a Characteristic in the ProjectedCharacteristicList used to order data in the QueryStatement's data set. If OrderingType DESC is specified, it indicates that data is ordered descending. Otherwise, it is ordered ascending.
		//*/
		//OrderingExpression : characteristic=ProjectedCharacteristicReference  (orderingType=OrderingType)? ;
		@Override public ParserRule getRule() { return rule; }
		
		//characteristic=ProjectedCharacteristicReference  (orderingType=OrderingType)?
		public Group getGroup() { return cGroup; }
		
		//characteristic=ProjectedCharacteristicReference
		public Assignment getCharacteristicAssignment_0() { return cCharacteristicAssignment_0; }
		
		//ProjectedCharacteristicReference
		public RuleCall getCharacteristicProjectedCharacteristicReferenceParserRuleCall_0_0() { return cCharacteristicProjectedCharacteristicReferenceParserRuleCall_0_0; }
		
		//(orderingType=OrderingType)?
		public Assignment getOrderingTypeAssignment_1() { return cOrderingTypeAssignment_1; }
		
		//OrderingType
		public RuleCall getOrderingTypeOrderingTypeParserRuleCall_1_0() { return cOrderingTypeOrderingTypeParserRuleCall_1_0; }
	}
	public class ProjectedCharacteristicReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ProjectedCharacteristicReference");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cQualifiedProjectedCharacteristicReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cUnqualifiedProjectedCharacteristicReferenceOrAliasParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A ProjectedCharacteristicReference is a reference to a Characteristic in the ProjectedCharacteristicList.
		//*/
		//ProjectedCharacteristicReference : QualifiedProjectedCharacteristicReference |  UnqualifiedProjectedCharacteristicReferenceOrAlias ;
		@Override public ParserRule getRule() { return rule; }
		
		//QualifiedProjectedCharacteristicReference |  UnqualifiedProjectedCharacteristicReferenceOrAlias
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//QualifiedProjectedCharacteristicReference
		public RuleCall getQualifiedProjectedCharacteristicReferenceParserRuleCall_0() { return cQualifiedProjectedCharacteristicReferenceParserRuleCall_0; }
		
		//UnqualifiedProjectedCharacteristicReferenceOrAlias
		public RuleCall getUnqualifiedProjectedCharacteristicReferenceOrAliasParserRuleCall_1() { return cUnqualifiedProjectedCharacteristicReferenceOrAliasParserRuleCall_1; }
	}
	public class QualifiedProjectedCharacteristicReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.QualifiedProjectedCharacteristicReference");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cSelectedEntityReferenceAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cSelectedEntityReferenceSelectedEntityReferenceParserRuleCall_0_0 = (RuleCall)cSelectedEntityReferenceAssignment_0.eContents().get(0);
		private final RuleCall cPERIODTerminalRuleCall_1 = (RuleCall)cGroup.eContents().get(1);
		private final Assignment cCharacteristicAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cCharacteristicCharacteristicReferenceParserRuleCall_2_0 = (RuleCall)cCharacteristicAssignment_2.eContents().get(0);
		
		///**
		//A QualifiedProjectedCharacteristicReference is a Characteristic specified by CharacteristicReference in the Entity specified by SelectedEntityReference.
		//*/
		//QualifiedProjectedCharacteristicReference : selectedEntityReference=SelectedEntityReference PERIOD  characteristic=CharacteristicReference ;
		@Override public ParserRule getRule() { return rule; }
		
		//selectedEntityReference=SelectedEntityReference PERIOD  characteristic=CharacteristicReference
		public Group getGroup() { return cGroup; }
		
		//selectedEntityReference=SelectedEntityReference
		public Assignment getSelectedEntityReferenceAssignment_0() { return cSelectedEntityReferenceAssignment_0; }
		
		//SelectedEntityReference
		public RuleCall getSelectedEntityReferenceSelectedEntityReferenceParserRuleCall_0_0() { return cSelectedEntityReferenceSelectedEntityReferenceParserRuleCall_0_0; }
		
		//PERIOD
		public RuleCall getPERIODTerminalRuleCall_1() { return cPERIODTerminalRuleCall_1; }
		
		//characteristic=CharacteristicReference
		public Assignment getCharacteristicAssignment_2() { return cCharacteristicAssignment_2; }
		
		//CharacteristicReference
		public RuleCall getCharacteristicCharacteristicReferenceParserRuleCall_2_0() { return cCharacteristicCharacteristicReferenceParserRuleCall_2_0; }
	}
	public class UnqualifiedProjectedCharacteristicReferenceOrAliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.UnqualifiedProjectedCharacteristicReferenceOrAlias");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//An UnqualifiedProjectedCharacteristicReferenceOrAlias is a Characteristic in ProjectedCharacteristicList whose rolename
		//or assigned ProjectedCharacteristicAlias is QueryIdentifier. If QueryIdentifier happens to match both a
		//ProjectedCharacteristicAlias and a rolename, then the Characteristic associated with the ProjectedCharacteristicAlias
		//is assumed.
		//*/
		//UnqualifiedProjectedCharacteristicReferenceOrAlias : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class OrderingTypeElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.OrderingType");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_ASCTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_DESCTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//An OrderingType specifies whether data is ordered ascending (KW_ASC) or descending (KW_DESC).
		//*/
		//OrderingType : KW_ASC | KW_DESC ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_ASC | KW_DESC
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//KW_ASC
		public RuleCall getKW_ASCTerminalRuleCall_0() { return cKW_ASCTerminalRuleCall_0; }
		
		//KW_DESC
		public RuleCall getKW_DESCTerminalRuleCall_1() { return cKW_DESCTerminalRuleCall_1; }
	}
	public class BooleanExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.BooleanExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cTermAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cTermBooleanTermParserRuleCall_0_0 = (RuleCall)cTermAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_ORTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cTermAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cTermBooleanTermParserRuleCall_1_1_0 = (RuleCall)cTermAssignment_1_1.eContents().get(0);
		
		///**
		// * Boolean expressions are left recursive. To address this, see the book p 169
		// */
		///**
		//A BooleanExpression is a boolean OR expression over boolean_terms.
		//*/
		//BooleanExpression : term+=BooleanTerm  ( KW_OR  term+=BooleanTerm )* ;
		@Override public ParserRule getRule() { return rule; }
		
		//term+=BooleanTerm  ( KW_OR  term+=BooleanTerm )*
		public Group getGroup() { return cGroup; }
		
		//term+=BooleanTerm
		public Assignment getTermAssignment_0() { return cTermAssignment_0; }
		
		//BooleanTerm
		public RuleCall getTermBooleanTermParserRuleCall_0_0() { return cTermBooleanTermParserRuleCall_0_0; }
		
		//( KW_OR  term+=BooleanTerm )*
		public Group getGroup_1() { return cGroup_1; }
		
		//KW_OR
		public RuleCall getKW_ORTerminalRuleCall_1_0() { return cKW_ORTerminalRuleCall_1_0; }
		
		//term+=BooleanTerm
		public Assignment getTermAssignment_1_1() { return cTermAssignment_1_1; }
		
		//BooleanTerm
		public RuleCall getTermBooleanTermParserRuleCall_1_1_0() { return cTermBooleanTermParserRuleCall_1_1_0; }
	}
	public class BooleanTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.BooleanTerm");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cFactorAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cFactorBooleanFactorParserRuleCall_0_0 = (RuleCall)cFactorAssignment_0.eContents().get(0);
		private final Group cGroup_1 = (Group)cGroup.eContents().get(1);
		private final RuleCall cKW_ANDTerminalRuleCall_1_0 = (RuleCall)cGroup_1.eContents().get(0);
		private final Assignment cFactorAssignment_1_1 = (Assignment)cGroup_1.eContents().get(1);
		private final RuleCall cFactorBooleanFactorParserRuleCall_1_1_0 = (RuleCall)cFactorAssignment_1_1.eContents().get(0);
		
		///**
		//A BooleanTerm is a boolean AND expression over boolean_factors.
		//*/
		//BooleanTerm : factor+=BooleanFactor  ( KW_AND  factor+=BooleanFactor )* ;
		@Override public ParserRule getRule() { return rule; }
		
		//factor+=BooleanFactor  ( KW_AND  factor+=BooleanFactor )*
		public Group getGroup() { return cGroup; }
		
		//factor+=BooleanFactor
		public Assignment getFactorAssignment_0() { return cFactorAssignment_0; }
		
		//BooleanFactor
		public RuleCall getFactorBooleanFactorParserRuleCall_0_0() { return cFactorBooleanFactorParserRuleCall_0_0; }
		
		//( KW_AND  factor+=BooleanFactor )*
		public Group getGroup_1() { return cGroup_1; }
		
		//KW_AND
		public RuleCall getKW_ANDTerminalRuleCall_1_0() { return cKW_ANDTerminalRuleCall_1_0; }
		
		//factor+=BooleanFactor
		public Assignment getFactorAssignment_1_1() { return cFactorAssignment_1_1; }
		
		//BooleanFactor
		public RuleCall getFactorBooleanFactorParserRuleCall_1_1_0() { return cFactorBooleanFactorParserRuleCall_1_1_0; }
	}
	public class BooleanFactorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.BooleanFactor");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cNotAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cNotKW_NOTTerminalRuleCall_0_0 = (RuleCall)cNotAssignment_0.eContents().get(0);
		private final Assignment cPredAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cPredBooleanPredicateParserRuleCall_1_0 = (RuleCall)cPredAssignment_1.eContents().get(0);
		
		///**
		//A BooleanFactor is a BooleanPredicate. If KW_NOT is not present, it evaluates the same as BooleanPredicate. If KW_NOT is present, the evaluation is the same but negated.
		//*/
		//BooleanFactor :  (not?=KW_NOT)?  pred=BooleanPredicate ;
		@Override public ParserRule getRule() { return rule; }
		
		//(not?=KW_NOT)?  pred=BooleanPredicate
		public Group getGroup() { return cGroup; }
		
		//(not?=KW_NOT)?
		public Assignment getNotAssignment_0() { return cNotAssignment_0; }
		
		//KW_NOT
		public RuleCall getNotKW_NOTTerminalRuleCall_0_0() { return cNotKW_NOTTerminalRuleCall_0_0; }
		
		//pred=BooleanPredicate
		public Assignment getPredAssignment_1() { return cPredAssignment_1; }
		
		//BooleanPredicate
		public RuleCall getPredBooleanPredicateParserRuleCall_1_0() { return cPredBooleanPredicateParserRuleCall_1_0; }
	}
	public class BooleanPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.BooleanPredicate");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cScalarComparePredicateParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cExistsPredicateParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final Group cGroup_2 = (Group)cAlternatives.eContents().get(2);
		private final RuleCall cLEFT_PARENTerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final RuleCall cBooleanExpressionParserRuleCall_2_1 = (RuleCall)cGroup_2.eContents().get(1);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_2_2 = (RuleCall)cGroup_2.eContents().get(2);
		
		///**
		// * NOTE: The problem with BooleanPredicate is when more than one of     ScalarComparePredicate | SetComparePredicate | SetMembershipPredicate  is uncommented.
		// * This results in a non LL grammar. Search for syntactic predicates in the book.
		// *
		// * TODO: fix this when we need set membership or set comparison capability
		// */
		///**
		//A BooleanPredicate is a predicate.
		//*/
		//BooleanPredicate :
		//    ScalarComparePredicate |
		////    SetComparePredicate |
		////    SetMembershipPredicate |
		//    ExistsPredicate |
		//    LEFT_PAREN  BooleanExpression  RIGHT_PAREN
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//    ScalarComparePredicate |
		////    SetComparePredicate |
		////    SetMembershipPredicate |
		//    ExistsPredicate |
		//    LEFT_PAREN  BooleanExpression  RIGHT_PAREN
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//ScalarComparePredicate
		public RuleCall getScalarComparePredicateParserRuleCall_0() { return cScalarComparePredicateParserRuleCall_0; }
		
		////    SetComparePredicate |
		////    SetMembershipPredicate |
		//    ExistsPredicate
		public RuleCall getExistsPredicateParserRuleCall_1() { return cExistsPredicateParserRuleCall_1; }
		
		//LEFT_PAREN  BooleanExpression  RIGHT_PAREN
		public Group getGroup_2() { return cGroup_2; }
		
		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_2_0() { return cLEFT_PARENTerminalRuleCall_2_0; }
		
		//BooleanExpression
		public RuleCall getBooleanExpressionParserRuleCall_2_1() { return cBooleanExpressionParserRuleCall_2_1; }
		
		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_2_2() { return cRIGHT_PARENTerminalRuleCall_2_2; }
	}
	public class ScalarComparePredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ScalarComparePredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftPredicateTermParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpCompareOperatorParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cRightAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cRightPredicateTermParserRuleCall_2_0 = (RuleCall)cRightAssignment_2.eContents().get(0);
		
		///**
		//A ScalarComparePredicate is a function that compares two PredicateTerms. It evaluates to TRUE if the comparison is true, FALSE otherwise.
		//*/
		//ScalarComparePredicate : left=PredicateTerm op=CompareOperator right=PredicateTerm ;
		@Override public ParserRule getRule() { return rule; }
		
		//left=PredicateTerm op=CompareOperator right=PredicateTerm
		public Group getGroup() { return cGroup; }
		
		//left=PredicateTerm
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//PredicateTerm
		public RuleCall getLeftPredicateTermParserRuleCall_0_0() { return cLeftPredicateTermParserRuleCall_0_0; }
		
		//op=CompareOperator
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }
		
		//CompareOperator
		public RuleCall getOpCompareOperatorParserRuleCall_1_0() { return cOpCompareOperatorParserRuleCall_1_0; }
		
		//right=PredicateTerm
		public Assignment getRightAssignment_2() { return cRightAssignment_2; }
		
		//PredicateTerm
		public RuleCall getRightPredicateTermParserRuleCall_2_0() { return cRightPredicateTermParserRuleCall_2_0; }
	}
	public class SetMembershipPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SetMembershipPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cLeftAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cLeftPredicateTermParserRuleCall_0_0 = (RuleCall)cLeftAssignment_0.eContents().get(0);
		private final Assignment cNotAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cNotKW_NOTTerminalRuleCall_1_0 = (RuleCall)cNotAssignment_1.eContents().get(0);
		private final RuleCall cKW_INTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cSetAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSetLogicalSetParserRuleCall_3_0 = (RuleCall)cSetAssignment_3.eContents().get(0);
		
		///**
		//A SetMembershipPredicate is a function that checks a PredicateTerm for membership in a LogicalSet. If KW_NOT is not present, it evaluates to TRUE if PredicateTerm is a member of LogicalSet, FALSE otherwise. If KW_NOT is present, the evaluation is the same but negated.
		//*/
		//SetMembershipPredicate : left=PredicateTerm  ( not?=KW_NOT)?  KW_IN  set=LogicalSet ;
		@Override public ParserRule getRule() { return rule; }
		
		//left=PredicateTerm  ( not?=KW_NOT)?  KW_IN  set=LogicalSet
		public Group getGroup() { return cGroup; }
		
		//left=PredicateTerm
		public Assignment getLeftAssignment_0() { return cLeftAssignment_0; }
		
		//PredicateTerm
		public RuleCall getLeftPredicateTermParserRuleCall_0_0() { return cLeftPredicateTermParserRuleCall_0_0; }
		
		//( not?=KW_NOT)?
		public Assignment getNotAssignment_1() { return cNotAssignment_1; }
		
		//KW_NOT
		public RuleCall getNotKW_NOTTerminalRuleCall_1_0() { return cNotKW_NOTTerminalRuleCall_1_0; }
		
		//KW_IN
		public RuleCall getKW_INTerminalRuleCall_2() { return cKW_INTerminalRuleCall_2; }
		
		//set=LogicalSet
		public Assignment getSetAssignment_3() { return cSetAssignment_3; }
		
		//LogicalSet
		public RuleCall getSetLogicalSetParserRuleCall_3_0() { return cSetLogicalSetParserRuleCall_3_0; }
	}
	public class LogicalSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LogicalSet");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSubqueryParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cCharacteristicBasisSetParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cEnumLiteralSetParserRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		
		///**
		//A LogicalSet is a set of data. If LogicalSet is a Subquery with one Characteristic in its ProjectedCharacteristicList, the set is the data associated with that Characteristic. If LogicalSet is a CharacteristicBasisSet, the set is the data associated with each CharacteristicBasis. If LogicalSet is an EnumLiteralSet, the set is the specified EnumerationLabels.
		//*/
		//LogicalSet : Subquery | CharacteristicBasisSet | EnumLiteralSet ;
		@Override public ParserRule getRule() { return rule; }
		
		//Subquery | CharacteristicBasisSet | EnumLiteralSet
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//Subquery
		public RuleCall getSubqueryParserRuleCall_0() { return cSubqueryParserRuleCall_0; }
		
		//CharacteristicBasisSet
		public RuleCall getCharacteristicBasisSetParserRuleCall_1() { return cCharacteristicBasisSetParserRuleCall_1; }
		
		//EnumLiteralSet
		public RuleCall getEnumLiteralSetParserRuleCall_2() { return cEnumLiteralSetParserRuleCall_2; }
	}
	public class CharacteristicBasisSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.CharacteristicBasisSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLEFT_PARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cCharacteristicBasisAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cCharacteristicBasisCharacteristicBasisParserRuleCall_1_0 = (RuleCall)cCharacteristicBasisAssignment_1.eContents().get(0);
		private final Group cGroup_2 = (Group)cGroup.eContents().get(2);
		private final RuleCall cCOMMATerminalRuleCall_2_0 = (RuleCall)cGroup_2.eContents().get(0);
		private final Assignment cCharacteristicBasisAssignment_2_1 = (Assignment)cGroup_2.eContents().get(1);
		private final RuleCall cCharacteristicBasisCharacteristicBasisParserRuleCall_2_1_0 = (RuleCall)cCharacteristicBasisAssignment_2_1.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_3 = (RuleCall)cGroup.eContents().get(3);
		
		///**
		//A CharacteristicBasisSet is one or more CharacteristicBasis.
		//*/
		//CharacteristicBasisSet : LEFT_PAREN  characteristicBasis+=CharacteristicBasis  ( COMMA  characteristicBasis+=CharacteristicBasis)*  RIGHT_PAREN ;
		@Override public ParserRule getRule() { return rule; }
		
		//LEFT_PAREN  characteristicBasis+=CharacteristicBasis  ( COMMA  characteristicBasis+=CharacteristicBasis)*  RIGHT_PAREN
		public Group getGroup() { return cGroup; }
		
		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_0() { return cLEFT_PARENTerminalRuleCall_0; }
		
		//characteristicBasis+=CharacteristicBasis
		public Assignment getCharacteristicBasisAssignment_1() { return cCharacteristicBasisAssignment_1; }
		
		//CharacteristicBasis
		public RuleCall getCharacteristicBasisCharacteristicBasisParserRuleCall_1_0() { return cCharacteristicBasisCharacteristicBasisParserRuleCall_1_0; }
		
		//( COMMA  characteristicBasis+=CharacteristicBasis)*
		public Group getGroup_2() { return cGroup_2; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_2_0() { return cCOMMATerminalRuleCall_2_0; }
		
		//characteristicBasis+=CharacteristicBasis
		public Assignment getCharacteristicBasisAssignment_2_1() { return cCharacteristicBasisAssignment_2_1; }
		
		//CharacteristicBasis
		public RuleCall getCharacteristicBasisCharacteristicBasisParserRuleCall_2_1_0() { return cCharacteristicBasisCharacteristicBasisParserRuleCall_2_1_0; }
		
		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_3() { return cRIGHT_PARENTerminalRuleCall_3; }
	}
	public class SetComparePredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SetComparePredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final Assignment cPredAssignment_0 = (Assignment)cGroup.eContents().get(0);
		private final RuleCall cPredPredicateTermParserRuleCall_0_0 = (RuleCall)cPredAssignment_0.eContents().get(0);
		private final Assignment cOpAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cOpCompareOperatorParserRuleCall_1_0 = (RuleCall)cOpAssignment_1.eContents().get(0);
		private final Assignment cQuantifierAssignment_2 = (Assignment)cGroup.eContents().get(2);
		private final RuleCall cQuantifierSetCompareQuantifierParserRuleCall_2_0 = (RuleCall)cQuantifierAssignment_2.eContents().get(0);
		private final Assignment cSetAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cSetCompareSetParserRuleCall_3_0 = (RuleCall)cSetAssignment_3.eContents().get(0);
		
		///**
		//A SetComparePredicate is a function that represents a pair-wise comparison of PredicateTerm with all members of CompareSet.
		//If SetCompareQuantifier is KW_ALL, the function evaluates to TRUE if the application of CompareOperator evaluates to TRUE
		//for PredicateTerm and every member of the set, FALSE otherwise. If SetCompareQuantifier is KW_SOME, the function evaluates to
		//TRUE if the application of CompareOperator evaluates to TRUE for PredicateTerm and at least one member in the set, FALSE otherwise.
		//*/
		//SetComparePredicate : pred=PredicateTerm  op=CompareOperator quantifier=SetCompareQuantifier set=CompareSet ;
		@Override public ParserRule getRule() { return rule; }
		
		//pred=PredicateTerm  op=CompareOperator quantifier=SetCompareQuantifier set=CompareSet
		public Group getGroup() { return cGroup; }
		
		//pred=PredicateTerm
		public Assignment getPredAssignment_0() { return cPredAssignment_0; }
		
		//PredicateTerm
		public RuleCall getPredPredicateTermParserRuleCall_0_0() { return cPredPredicateTermParserRuleCall_0_0; }
		
		//op=CompareOperator
		public Assignment getOpAssignment_1() { return cOpAssignment_1; }
		
		//CompareOperator
		public RuleCall getOpCompareOperatorParserRuleCall_1_0() { return cOpCompareOperatorParserRuleCall_1_0; }
		
		//quantifier=SetCompareQuantifier
		public Assignment getQuantifierAssignment_2() { return cQuantifierAssignment_2; }
		
		//SetCompareQuantifier
		public RuleCall getQuantifierSetCompareQuantifierParserRuleCall_2_0() { return cQuantifierSetCompareQuantifierParserRuleCall_2_0; }
		
		//set=CompareSet
		public Assignment getSetAssignment_3() { return cSetAssignment_3; }
		
		//CompareSet
		public RuleCall getSetCompareSetParserRuleCall_3_0() { return cSetCompareSetParserRuleCall_3_0; }
	}
	public class CompareSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.CompareSet");
		private final RuleCall cSubqueryParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A CompareSet is a Subquery with a single Characteristic in its ProjectedCharacteristicList.
		//*/
		//CompareSet : Subquery ;
		@Override public ParserRule getRule() { return rule; }
		
		//Subquery
		public RuleCall getSubqueryParserRuleCall() { return cSubqueryParserRuleCall; }
	}
	public class CompareOperatorElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.CompareOperator");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cEQUALS_OPERATORTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cNOT_EQUALS_OPERATORTerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		private final RuleCall cLESS_THAN_OPERATORTerminalRuleCall_2 = (RuleCall)cAlternatives.eContents().get(2);
		private final RuleCall cGREATER_THAN_OPERATORTerminalRuleCall_3 = (RuleCall)cAlternatives.eContents().get(3);
		private final RuleCall cLESS_THAN_OR_EQUALS_OPERATORTerminalRuleCall_4 = (RuleCall)cAlternatives.eContents().get(4);
		private final RuleCall cGREATER_THAN_OR_EQUALS_OPERATORTerminalRuleCall_5 = (RuleCall)cAlternatives.eContents().get(5);
		
		///**
		//A CompareOperator is a boolean comparison operator.
		//*/
		//CompareOperator : EQUALS_OPERATOR | NOT_EQUALS_OPERATOR |
		//                  LESS_THAN_OPERATOR | GREATER_THAN_OPERATOR | LESS_THAN_OR_EQUALS_OPERATOR | GREATER_THAN_OR_EQUALS_OPERATOR
		//;
		@Override public ParserRule getRule() { return rule; }
		
		//EQUALS_OPERATOR | NOT_EQUALS_OPERATOR |
		//                 LESS_THAN_OPERATOR | GREATER_THAN_OPERATOR | LESS_THAN_OR_EQUALS_OPERATOR | GREATER_THAN_OR_EQUALS_OPERATOR
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//EQUALS_OPERATOR
		public RuleCall getEQUALS_OPERATORTerminalRuleCall_0() { return cEQUALS_OPERATORTerminalRuleCall_0; }
		
		//NOT_EQUALS_OPERATOR
		public RuleCall getNOT_EQUALS_OPERATORTerminalRuleCall_1() { return cNOT_EQUALS_OPERATORTerminalRuleCall_1; }
		
		//LESS_THAN_OPERATOR
		public RuleCall getLESS_THAN_OPERATORTerminalRuleCall_2() { return cLESS_THAN_OPERATORTerminalRuleCall_2; }
		
		//GREATER_THAN_OPERATOR
		public RuleCall getGREATER_THAN_OPERATORTerminalRuleCall_3() { return cGREATER_THAN_OPERATORTerminalRuleCall_3; }
		
		//LESS_THAN_OR_EQUALS_OPERATOR
		public RuleCall getLESS_THAN_OR_EQUALS_OPERATORTerminalRuleCall_4() { return cLESS_THAN_OR_EQUALS_OPERATORTerminalRuleCall_4; }
		
		//GREATER_THAN_OR_EQUALS_OPERATOR
		public RuleCall getGREATER_THAN_OR_EQUALS_OPERATORTerminalRuleCall_5() { return cGREATER_THAN_OR_EQUALS_OPERATORTerminalRuleCall_5; }
	}
	public class SetCompareQuantifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SetCompareQuantifier");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cKW_ALLTerminalRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cKW_SOMETerminalRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A SetCompareQuantifier indicates that a comparison applies to every (KW_ALL) or any (KW_SOME) member of a set.
		//*/
		//SetCompareQuantifier : KW_ALL | KW_SOME ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_ALL | KW_SOME
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//KW_ALL
		public RuleCall getKW_ALLTerminalRuleCall_0() { return cKW_ALLTerminalRuleCall_0; }
		
		//KW_SOME
		public RuleCall getKW_SOMETerminalRuleCall_1() { return cKW_SOMETerminalRuleCall_1; }
	}
	public class ExistsPredicateElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ExistsPredicate");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cKW_EXISTSTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cSubAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cSubSubqueryParserRuleCall_1_0 = (RuleCall)cSubAssignment_1.eContents().get(0);
		
		///**
		//An ExistsPredicate is a function that evaluates to TRUE if there is any data associated with the single Characteristic in Subquery's ProjectedCharacteristicList, FALSE otherwise.
		//*/
		//ExistsPredicate : KW_EXISTS  sub=Subquery ;
		@Override public ParserRule getRule() { return rule; }
		
		//KW_EXISTS  sub=Subquery
		public Group getGroup() { return cGroup; }
		
		//KW_EXISTS
		public RuleCall getKW_EXISTSTerminalRuleCall_0() { return cKW_EXISTSTerminalRuleCall_0; }
		
		//sub=Subquery
		public Assignment getSubAssignment_1() { return cSubAssignment_1; }
		
		//Subquery
		public RuleCall getSubSubqueryParserRuleCall_1_0() { return cSubSubqueryParserRuleCall_1_0; }
	}
	public class PredicateTermElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.PredicateTerm");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cCharacteristicBasisParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cEnumLiteralReferenceExpressionParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A PredicateTerm represents a DataModel Element whose associated data is scalar.
		//*/
		//PredicateTerm : CharacteristicBasis | EnumLiteralReferenceExpression ;
		@Override public ParserRule getRule() { return rule; }
		
		//CharacteristicBasis | EnumLiteralReferenceExpression
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//CharacteristicBasis
		public RuleCall getCharacteristicBasisParserRuleCall_0() { return cCharacteristicBasisParserRuleCall_0; }
		
		//EnumLiteralReferenceExpression
		public RuleCall getEnumLiteralReferenceExpressionParserRuleCall_1() { return cEnumLiteralReferenceExpressionParserRuleCall_1; }
	}
	public class CharacteristicBasisElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.CharacteristicBasis");
		private final Alternatives cAlternatives = (Alternatives)rule.eContents().get(1);
		private final RuleCall cSelectedEntityCharacteristicReferenceParserRuleCall_0 = (RuleCall)cAlternatives.eContents().get(0);
		private final RuleCall cSubqueryParserRuleCall_1 = (RuleCall)cAlternatives.eContents().get(1);
		
		///**
		//A CharacteristicBasis is a Characteristic whose associated data is scalar. If CharacteristicBasis is a
		//Subquery with one Characteristic in its ProjectedCharacteristicList, then the CharacteristicBasis is that Characteristic.
		//Otherwise, the Characteristic is specified by SelectedEntityCharacteristicReference.
		//*/
		//CharacteristicBasis : SelectedEntityCharacteristicReference | Subquery ;
		@Override public ParserRule getRule() { return rule; }
		
		//SelectedEntityCharacteristicReference | Subquery
		public Alternatives getAlternatives() { return cAlternatives; }
		
		//SelectedEntityCharacteristicReference
		public RuleCall getSelectedEntityCharacteristicReferenceParserRuleCall_0() { return cSelectedEntityCharacteristicReferenceParserRuleCall_0; }
		
		//Subquery
		public RuleCall getSubqueryParserRuleCall_1() { return cSubqueryParserRuleCall_1; }
	}
	public class SubqueryElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.Subquery");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLEFT_PARENTerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cQueryAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cQueryQueryStatementParserRuleCall_1_0 = (RuleCall)cQueryAssignment_1.eContents().get(0);
		private final RuleCall cRIGHT_PARENTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		
		///**
		//A Subquery is a QueryStatement that is nested inside another QueryStatement.
		//*/
		//Subquery : LEFT_PAREN  query=QueryStatement  RIGHT_PAREN ;
		@Override public ParserRule getRule() { return rule; }
		
		//LEFT_PAREN  query=QueryStatement  RIGHT_PAREN
		public Group getGroup() { return cGroup; }
		
		//LEFT_PAREN
		public RuleCall getLEFT_PARENTerminalRuleCall_0() { return cLEFT_PARENTerminalRuleCall_0; }
		
		//query=QueryStatement
		public Assignment getQueryAssignment_1() { return cQueryAssignment_1; }
		
		//QueryStatement
		public RuleCall getQueryQueryStatementParserRuleCall_1_0() { return cQueryQueryStatementParserRuleCall_1_0; }
		
		//RIGHT_PAREN
		public RuleCall getRIGHT_PARENTerminalRuleCall_2() { return cRIGHT_PARENTerminalRuleCall_2; }
	}
	public class CharacteristicReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.CharacteristicReference");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A CharacteristicReference is a Characteristic whose rolename matches QueryIdentifier.
		//*/
		//CharacteristicReference : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class EntityTypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EntityTypeReference");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//An EntityTypeReference is the Entity whose name matches QueryIdentifier.
		//*/
		//EntityTypeReference : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class EnumLiteralSetElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EnumLiteralSet");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLEFT_BRACETerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cTypeAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypeEnumerationTypeReferenceParserRuleCall_1_0 = (RuleCall)cTypeAssignment_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLiteralAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLiteralEnumerationLiteralReferenceParserRuleCall_3_0 = (RuleCall)cLiteralAssignment_3.eContents().get(0);
		private final Group cGroup_4 = (Group)cGroup.eContents().get(4);
		private final RuleCall cCOMMATerminalRuleCall_4_0 = (RuleCall)cGroup_4.eContents().get(0);
		private final Assignment cLiteralAssignment_4_1 = (Assignment)cGroup_4.eContents().get(1);
		private final RuleCall cLiteralEnumerationLiteralReferenceParserRuleCall_4_1_0 = (RuleCall)cLiteralAssignment_4_1.eContents().get(0);
		private final RuleCall cRIGHT_BRACETerminalRuleCall_5 = (RuleCall)cGroup.eContents().get(5);
		
		///**
		//An EnumLiteralSet is a set of EnumerationLabels. Each member in the set is identified by the EnumerationLabel whose name is EnumerationLiteralReference in the Enumerated whose name is EnumerationTypeReference.
		//*/
		//EnumLiteralSet : LEFT_BRACE type=EnumerationTypeReference COLON  literal+=EnumerationLiteralReference  ( COMMA  literal+=EnumerationLiteralReference )* RIGHT_BRACE ;
		@Override public ParserRule getRule() { return rule; }
		
		//LEFT_BRACE type=EnumerationTypeReference COLON  literal+=EnumerationLiteralReference  ( COMMA  literal+=EnumerationLiteralReference )* RIGHT_BRACE
		public Group getGroup() { return cGroup; }
		
		//LEFT_BRACE
		public RuleCall getLEFT_BRACETerminalRuleCall_0() { return cLEFT_BRACETerminalRuleCall_0; }
		
		//type=EnumerationTypeReference
		public Assignment getTypeAssignment_1() { return cTypeAssignment_1; }
		
		//EnumerationTypeReference
		public RuleCall getTypeEnumerationTypeReferenceParserRuleCall_1_0() { return cTypeEnumerationTypeReferenceParserRuleCall_1_0; }
		
		//COLON
		public RuleCall getCOLONTerminalRuleCall_2() { return cCOLONTerminalRuleCall_2; }
		
		//literal+=EnumerationLiteralReference
		public Assignment getLiteralAssignment_3() { return cLiteralAssignment_3; }
		
		//EnumerationLiteralReference
		public RuleCall getLiteralEnumerationLiteralReferenceParserRuleCall_3_0() { return cLiteralEnumerationLiteralReferenceParserRuleCall_3_0; }
		
		//( COMMA  literal+=EnumerationLiteralReference )*
		public Group getGroup_4() { return cGroup_4; }
		
		//COMMA
		public RuleCall getCOMMATerminalRuleCall_4_0() { return cCOMMATerminalRuleCall_4_0; }
		
		//literal+=EnumerationLiteralReference
		public Assignment getLiteralAssignment_4_1() { return cLiteralAssignment_4_1; }
		
		//EnumerationLiteralReference
		public RuleCall getLiteralEnumerationLiteralReferenceParserRuleCall_4_1_0() { return cLiteralEnumerationLiteralReferenceParserRuleCall_4_1_0; }
		
		//RIGHT_BRACE
		public RuleCall getRIGHT_BRACETerminalRuleCall_5() { return cRIGHT_BRACETerminalRuleCall_5; }
	}
	public class EnumLiteralReferenceExpressionElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EnumLiteralReferenceExpression");
		private final Group cGroup = (Group)rule.eContents().get(1);
		private final RuleCall cLEFT_BRACETerminalRuleCall_0 = (RuleCall)cGroup.eContents().get(0);
		private final Assignment cTypAssignment_1 = (Assignment)cGroup.eContents().get(1);
		private final RuleCall cTypEnumerationTypeReferenceParserRuleCall_1_0 = (RuleCall)cTypAssignment_1.eContents().get(0);
		private final RuleCall cCOLONTerminalRuleCall_2 = (RuleCall)cGroup.eContents().get(2);
		private final Assignment cLiteralAssignment_3 = (Assignment)cGroup.eContents().get(3);
		private final RuleCall cLiteralEnumerationLiteralReferenceParserRuleCall_3_0 = (RuleCall)cLiteralAssignment_3.eContents().get(0);
		private final RuleCall cRIGHT_BRACETerminalRuleCall_4 = (RuleCall)cGroup.eContents().get(4);
		
		///**
		//An EnumLiteralReferenceExpression is an EnumerationLabel whose name is EnumerationLiteralReference in the Enumerated whose name is EnumerationTypeReference.
		//*/
		//EnumLiteralReferenceExpression : LEFT_BRACE  typ=EnumerationTypeReference  COLON  literal=EnumerationLiteralReference RIGHT_BRACE ;
		@Override public ParserRule getRule() { return rule; }
		
		//LEFT_BRACE  typ=EnumerationTypeReference  COLON  literal=EnumerationLiteralReference RIGHT_BRACE
		public Group getGroup() { return cGroup; }
		
		//LEFT_BRACE
		public RuleCall getLEFT_BRACETerminalRuleCall_0() { return cLEFT_BRACETerminalRuleCall_0; }
		
		//typ=EnumerationTypeReference
		public Assignment getTypAssignment_1() { return cTypAssignment_1; }
		
		//EnumerationTypeReference
		public RuleCall getTypEnumerationTypeReferenceParserRuleCall_1_0() { return cTypEnumerationTypeReferenceParserRuleCall_1_0; }
		
		//COLON
		public RuleCall getCOLONTerminalRuleCall_2() { return cCOLONTerminalRuleCall_2; }
		
		//literal=EnumerationLiteralReference
		public Assignment getLiteralAssignment_3() { return cLiteralAssignment_3; }
		
		//EnumerationLiteralReference
		public RuleCall getLiteralEnumerationLiteralReferenceParserRuleCall_3_0() { return cLiteralEnumerationLiteralReferenceParserRuleCall_3_0; }
		
		//RIGHT_BRACE
		public RuleCall getRIGHT_BRACETerminalRuleCall_4() { return cRIGHT_BRACETerminalRuleCall_4; }
	}
	public class EnumerationTypeReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EnumerationTypeReference");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//An EnumerationTypeReference is the Enumerated whose name matches QueryIdentifier.
		//*/
		//EnumerationTypeReference : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class EnumerationLiteralReferenceElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EnumerationLiteralReference");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//An EnumerationLiteralReference is an EnumerationLabel whose name matches QueryIdentifier.
		//*/
		//EnumerationLiteralReference : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class SelectedEntityAliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.SelectedEntityAlias");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A SelectedEntityAlias is an alias for a SelectedEntity.
		//*/
		//SelectedEntityAlias : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class ProjectedCharacteristicAliasElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ProjectedCharacteristicAlias");
		private final RuleCall cQueryIdentifierParserRuleCall = (RuleCall)rule.eContents().get(1);
		
		///**
		//A ProjectedCharacteristicAlias provides an alias for a Characteristic in a ProjectedCharacteristicList.
		//*/
		//ProjectedCharacteristicAlias : QueryIdentifier ;
		@Override public ParserRule getRule() { return rule; }
		
		//QueryIdentifier
		public RuleCall getQueryIdentifierParserRuleCall() { return cQueryIdentifierParserRuleCall; }
	}
	public class QueryIdentifierElements extends AbstractParserRuleElementFinder {
		private final ParserRule rule = (ParserRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.QueryIdentifier");
		private final Assignment cIdAssignment = (Assignment)rule.eContents().get(1);
		private final RuleCall cIdIDENTIFIERTerminalRuleCall_0 = (RuleCall)cIdAssignment.eContents().get(0);
		
		///**
		//A QueryIdentifier is an alphanumeric string used to represent an Identifier in a QuerySpecification.
		//*/
		//QueryIdentifier : id=IDENTIFIER ;
		@Override public ParserRule getRule() { return rule; }
		
		//id=IDENTIFIER
		public Assignment getIdAssignment() { return cIdAssignment; }
		
		//IDENTIFIER
		public RuleCall getIdIDENTIFIERTerminalRuleCall_0() { return cIdIDENTIFIERTerminalRuleCall_0; }
	}
	
	
	private final QuerySpecificationElements pQuerySpecification;
	private final QueryStatementElements pQueryStatement;
	private final SetQualifierElements pSetQualifier;
	private final ProjectedCharacteristicListElements pProjectedCharacteristicList;
	private final TerminalRule tALL_CHARACTERISTICS;
	private final ProjectedCharacteristicExpressionElements pProjectedCharacteristicExpression;
	private final SelectedEntityCharacteristicWildcardReferenceElements pSelectedEntityCharacteristicWildcardReference;
	private final ExplicitSelectedEntityCharacteristicReferenceElements pExplicitSelectedEntityCharacteristicReference;
	private final SelectedEntityExpressionElements pSelectedEntityExpression;
	private final FromClauseElements pFromClause;
	private final EntityExpressionElements pEntityExpression;
	private final SelectedEntityElements pSelectedEntity;
	private final EntityJoinExpressionElements pEntityJoinExpression;
	private final JoinEntityElements pJoinEntity;
	private final EntityJoinCriteriaElements pEntityJoinCriteria;
	private final EntityTypeCharacteristicEquivalenceExpressionElements pEntityTypeCharacteristicEquivalenceExpression;
	private final SelectedEntityCharacteristicReferenceElements pSelectedEntityCharacteristicReference;
	private final SelectedEntityReferenceElements pSelectedEntityReference;
	private final WhereClauseElements pWhereClause;
	private final CriteriaElements pCriteria;
	private final OrderByClauseElements pOrderByClause;
	private final OrderingExpressionElements pOrderingExpression;
	private final ProjectedCharacteristicReferenceElements pProjectedCharacteristicReference;
	private final QualifiedProjectedCharacteristicReferenceElements pQualifiedProjectedCharacteristicReference;
	private final UnqualifiedProjectedCharacteristicReferenceOrAliasElements pUnqualifiedProjectedCharacteristicReferenceOrAlias;
	private final OrderingTypeElements pOrderingType;
	private final BooleanExpressionElements pBooleanExpression;
	private final BooleanTermElements pBooleanTerm;
	private final BooleanFactorElements pBooleanFactor;
	private final BooleanPredicateElements pBooleanPredicate;
	private final ScalarComparePredicateElements pScalarComparePredicate;
	private final SetMembershipPredicateElements pSetMembershipPredicate;
	private final LogicalSetElements pLogicalSet;
	private final CharacteristicBasisSetElements pCharacteristicBasisSet;
	private final SetComparePredicateElements pSetComparePredicate;
	private final CompareSetElements pCompareSet;
	private final CompareOperatorElements pCompareOperator;
	private final SetCompareQuantifierElements pSetCompareQuantifier;
	private final ExistsPredicateElements pExistsPredicate;
	private final PredicateTermElements pPredicateTerm;
	private final CharacteristicBasisElements pCharacteristicBasis;
	private final SubqueryElements pSubquery;
	private final CharacteristicReferenceElements pCharacteristicReference;
	private final EntityTypeReferenceElements pEntityTypeReference;
	private final EnumLiteralSetElements pEnumLiteralSet;
	private final EnumLiteralReferenceExpressionElements pEnumLiteralReferenceExpression;
	private final EnumerationTypeReferenceElements pEnumerationTypeReference;
	private final EnumerationLiteralReferenceElements pEnumerationLiteralReference;
	private final SelectedEntityAliasElements pSelectedEntityAlias;
	private final ProjectedCharacteristicAliasElements pProjectedCharacteristicAlias;
	private final QueryIdentifierElements pQueryIdentifier;
	private final TerminalRule tKW_ALL;
	private final TerminalRule tKW_SOME;
	private final TerminalRule tKW_EXISTS;
	private final TerminalRule tKW_NOT;
	private final TerminalRule tKW_IN;
	private final TerminalRule tKW_AND;
	private final TerminalRule tKW_OR;
	private final TerminalRule tKW_AS;
	private final TerminalRule tKW_DISTINCT;
	private final TerminalRule tKW_WHERE;
	private final TerminalRule tKW_BY;
	private final TerminalRule tKW_JOIN;
	private final TerminalRule tKW_ON;
	private final TerminalRule tKW_ORDER;
	private final TerminalRule tKW_ASC;
	private final TerminalRule tKW_DESC;
	private final TerminalRule tEQUALS_OPERATOR;
	private final TerminalRule tNOT_EQUALS_OPERATOR;
	private final TerminalRule tLESS_THAN_OPERATOR;
	private final TerminalRule tGREATER_THAN_OPERATOR;
	private final TerminalRule tGREATER_THAN_OR_EQUALS_OPERATOR;
	private final TerminalRule tLESS_THAN_OR_EQUALS_OPERATOR;
	private final TerminalRule tCOMMA;
	private final TerminalRule tLEFT_PAREN;
	private final TerminalRule tRIGHT_PAREN;
	private final TerminalRule tPERIOD;
	private final TerminalRule tLEFT_BRACE;
	private final TerminalRule tRIGHT_BRACE;
	private final TerminalRule tCOLON;
	private final TerminalRule tIDENTIFIER;
	private final TerminalRule tLETTER;
	private final TerminalRule tDIGITAL_LITERAL;
	
	private final Grammar grammar;
	
	private final TerminalsGrammarAccess gaTerminals;

	@Inject
	public QueryGrammarAccess(GrammarProvider grammarProvider,
			TerminalsGrammarAccess gaTerminals) {
		this.grammar = internalFindGrammar(grammarProvider);
		this.gaTerminals = gaTerminals;
		this.pQuerySpecification = new QuerySpecificationElements();
		this.pQueryStatement = new QueryStatementElements();
		this.pSetQualifier = new SetQualifierElements();
		this.pProjectedCharacteristicList = new ProjectedCharacteristicListElements();
		this.tALL_CHARACTERISTICS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.ALL_CHARACTERISTICS");
		this.pProjectedCharacteristicExpression = new ProjectedCharacteristicExpressionElements();
		this.pSelectedEntityCharacteristicWildcardReference = new SelectedEntityCharacteristicWildcardReferenceElements();
		this.pExplicitSelectedEntityCharacteristicReference = new ExplicitSelectedEntityCharacteristicReferenceElements();
		this.pSelectedEntityExpression = new SelectedEntityExpressionElements();
		this.pFromClause = new FromClauseElements();
		this.pEntityExpression = new EntityExpressionElements();
		this.pSelectedEntity = new SelectedEntityElements();
		this.pEntityJoinExpression = new EntityJoinExpressionElements();
		this.pJoinEntity = new JoinEntityElements();
		this.pEntityJoinCriteria = new EntityJoinCriteriaElements();
		this.pEntityTypeCharacteristicEquivalenceExpression = new EntityTypeCharacteristicEquivalenceExpressionElements();
		this.pSelectedEntityCharacteristicReference = new SelectedEntityCharacteristicReferenceElements();
		this.pSelectedEntityReference = new SelectedEntityReferenceElements();
		this.pWhereClause = new WhereClauseElements();
		this.pCriteria = new CriteriaElements();
		this.pOrderByClause = new OrderByClauseElements();
		this.pOrderingExpression = new OrderingExpressionElements();
		this.pProjectedCharacteristicReference = new ProjectedCharacteristicReferenceElements();
		this.pQualifiedProjectedCharacteristicReference = new QualifiedProjectedCharacteristicReferenceElements();
		this.pUnqualifiedProjectedCharacteristicReferenceOrAlias = new UnqualifiedProjectedCharacteristicReferenceOrAliasElements();
		this.pOrderingType = new OrderingTypeElements();
		this.pBooleanExpression = new BooleanExpressionElements();
		this.pBooleanTerm = new BooleanTermElements();
		this.pBooleanFactor = new BooleanFactorElements();
		this.pBooleanPredicate = new BooleanPredicateElements();
		this.pScalarComparePredicate = new ScalarComparePredicateElements();
		this.pSetMembershipPredicate = new SetMembershipPredicateElements();
		this.pLogicalSet = new LogicalSetElements();
		this.pCharacteristicBasisSet = new CharacteristicBasisSetElements();
		this.pSetComparePredicate = new SetComparePredicateElements();
		this.pCompareSet = new CompareSetElements();
		this.pCompareOperator = new CompareOperatorElements();
		this.pSetCompareQuantifier = new SetCompareQuantifierElements();
		this.pExistsPredicate = new ExistsPredicateElements();
		this.pPredicateTerm = new PredicateTermElements();
		this.pCharacteristicBasis = new CharacteristicBasisElements();
		this.pSubquery = new SubqueryElements();
		this.pCharacteristicReference = new CharacteristicReferenceElements();
		this.pEntityTypeReference = new EntityTypeReferenceElements();
		this.pEnumLiteralSet = new EnumLiteralSetElements();
		this.pEnumLiteralReferenceExpression = new EnumLiteralReferenceExpressionElements();
		this.pEnumerationTypeReference = new EnumerationTypeReferenceElements();
		this.pEnumerationLiteralReference = new EnumerationLiteralReferenceElements();
		this.pSelectedEntityAlias = new SelectedEntityAliasElements();
		this.pProjectedCharacteristicAlias = new ProjectedCharacteristicAliasElements();
		this.pQueryIdentifier = new QueryIdentifierElements();
		this.tKW_ALL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_ALL");
		this.tKW_SOME = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_SOME");
		this.tKW_EXISTS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_EXISTS");
		this.tKW_NOT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_NOT");
		this.tKW_IN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_IN");
		this.tKW_AND = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_AND");
		this.tKW_OR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_OR");
		this.tKW_AS = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_AS");
		this.tKW_DISTINCT = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_DISTINCT");
		this.tKW_WHERE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_WHERE");
		this.tKW_BY = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_BY");
		this.tKW_JOIN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_JOIN");
		this.tKW_ON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_ON");
		this.tKW_ORDER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_ORDER");
		this.tKW_ASC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_ASC");
		this.tKW_DESC = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.KW_DESC");
		this.tEQUALS_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.EQUALS_OPERATOR");
		this.tNOT_EQUALS_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.NOT_EQUALS_OPERATOR");
		this.tLESS_THAN_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LESS_THAN_OPERATOR");
		this.tGREATER_THAN_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.GREATER_THAN_OPERATOR");
		this.tGREATER_THAN_OR_EQUALS_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.GREATER_THAN_OR_EQUALS_OPERATOR");
		this.tLESS_THAN_OR_EQUALS_OPERATOR = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LESS_THAN_OR_EQUALS_OPERATOR");
		this.tCOMMA = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.COMMA");
		this.tLEFT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LEFT_PAREN");
		this.tRIGHT_PAREN = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.RIGHT_PAREN");
		this.tPERIOD = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.PERIOD");
		this.tLEFT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LEFT_BRACE");
		this.tRIGHT_BRACE = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.RIGHT_BRACE");
		this.tCOLON = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.COLON");
		this.tIDENTIFIER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.IDENTIFIER");
		this.tLETTER = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.LETTER");
		this.tDIGITAL_LITERAL = (TerminalRule) GrammarUtil.findRuleForName(getGrammar(), "com.epistimis.uddl.query.Query.DIGITAL_LITERAL");
	}
	
	protected Grammar internalFindGrammar(GrammarProvider grammarProvider) {
		Grammar grammar = grammarProvider.getGrammar(this);
		while (grammar != null) {
			if ("com.epistimis.uddl.query.Query".equals(grammar.getName())) {
				return grammar;
			}
			List<Grammar> grammars = grammar.getUsedGrammars();
			if (!grammars.isEmpty()) {
				grammar = grammars.iterator().next();
			} else {
				return null;
			}
		}
		return grammar;
	}
	
	@Override
	public Grammar getGrammar() {
		return grammar;
	}
	
	
	public TerminalsGrammarAccess getTerminalsGrammarAccess() {
		return gaTerminals;
	}

	
	///**
	// * https://stackoverflow.com/questions/30889847/match-string-in-xtext-regardless-of-upper-lower-case (second, more recent response) indicates how
	// * to get case insensitive keywords. But this means that they must be keywords, not Terminals.
	// * TODO: replace Replace grammar terminals keywords with literal keywords. What impact does this have on Langium?
	// *
	// * BooleanPredicate is not LL. See book for how to handle this. This modification is because the original grammar is ANTLR 4, but XText only
	// * supports ANTLR 3.
	// */
	///**
	//A QuerySpecification represents a Query in the Data Model.
	//*/
	//QuerySpecification : QueryStatement ;
	public QuerySpecificationElements getQuerySpecificationAccess() {
		return pQuerySpecification;
	}
	
	public ParserRule getQuerySpecificationRule() {
		return getQuerySpecificationAccess().getRule();
	}
	
	///**
	//A QueryStatement is the expression of a Query, which is a declaration of a set of data in terms of a set of Entities and their
	//Characteristics. The SelectedEntityExpression defines the context for a QueryStatement's data set as a set of related Entities
	//and optionally a set of conditions expressed over their Characteristics that are true for all data in the data set.
	//The ProjectedCharacteristicList identifies the specific Characteristics that are the elements of the QueryStatement's data set.
	//The SetQualifier DISTINCT, if specified, indicates that instances of data in the data set are not duplicated. Otherwise,
	//they may be duplicated.
	//*
	//* Optionally followed by a semicolon
	//*
	//*/
	////QueryStatement : KW_SELECT , [ SetQualifier ] , ProjectedCharacteristicList , SelectedEntityExpression ;
	//QueryStatement : 'select' ( qualifier=SetQualifier )? projectedCharacteristicList=ProjectedCharacteristicList
	//    selectedEntityExpression=SelectedEntityExpression ';'?
	//;
	public QueryStatementElements getQueryStatementAccess() {
		return pQueryStatement;
	}
	
	public ParserRule getQueryStatementRule() {
		return getQueryStatementAccess().getRule();
	}
	
	///**
	//A SetQualifier indicates whether instances of data in a set are unique (KW_DISTINCT) or not (KW_ALL).
	//*/
	//SetQualifier : KW_DISTINCT | KW_ALL ;
	public SetQualifierElements getSetQualifierAccess() {
		return pSetQualifier;
	}
	
	public ParserRule getSetQualifierRule() {
		return getSetQualifierAccess().getRule();
	}
	
	///**
	//A ProjectedCharacteristicList defines the set of Characteristics in a QueryStatement. ALL_CHARACTERISTICS indicates that every
	//Characteristic of every SelectedEntity is included. Otherwise, the Characteristics are those specified by the
	//projected_characteristic_expressions. In both cases, only those Characteristics whose types are not Entities are included.
	//*/
	//ProjectedCharacteristicList : all=ALL_CHARACTERISTICS | characteristic+=ProjectedCharacteristicExpression  ( COMMA  characteristic+=ProjectedCharacteristicExpression )* ;
	public ProjectedCharacteristicListElements getProjectedCharacteristicListAccess() {
		return pProjectedCharacteristicList;
	}
	
	public ParserRule getProjectedCharacteristicListRule() {
		return getProjectedCharacteristicListAccess().getRule();
	}
	
	///**
	//ALL_CHARACTERISTICS is a shorthand notation indicating "every Characteristic".
	//*/
	//terminal ALL_CHARACTERISTICS : "*" ;
	public TerminalRule getALL_CHARACTERISTICSRule() {
		return tALL_CHARACTERISTICS;
	}
	
	///**
	//A ProjectedCharacteristicExpression represents one or more Characteristics of a specific Entity.
	//*/
	//ProjectedCharacteristicExpression : SelectedEntityCharacteristicWildcardReference | ExplicitSelectedEntityCharacteristicReference ;
	public ProjectedCharacteristicExpressionElements getProjectedCharacteristicExpressionAccess() {
		return pProjectedCharacteristicExpression;
	}
	
	public ParserRule getProjectedCharacteristicExpressionRule() {
		return getProjectedCharacteristicExpressionAccess().getRule();
	}
	
	///**
	//A SelectedEntityCharacteristicWildcardReference is a shorthand notation indicating "every Characteristic of SelectedEntityReference".
	//*/
	//SelectedEntityCharacteristicWildcardReference : selectedEntity=SelectedEntityReference  PERIOD  ALL_CHARACTERISTICS ;
	public SelectedEntityCharacteristicWildcardReferenceElements getSelectedEntityCharacteristicWildcardReferenceAccess() {
		return pSelectedEntityCharacteristicWildcardReference;
	}
	
	public ParserRule getSelectedEntityCharacteristicWildcardReferenceRule() {
		return getSelectedEntityCharacteristicWildcardReferenceAccess().getRule();
	}
	
	///**
	//An ExplicitSelectedEntityCharacteristicReference represents one Characteristic of one Entity. ProjectedCharacteristicAlias specifies an optional alias for the Characteristic for use elsewhere in a QueryStatement.
	//*/
	//ExplicitSelectedEntityCharacteristicReference : selectedEntityCharacteristicReference=SelectedEntityCharacteristicReference  ( ( KW_AS )?  projectedCharacteristicAlias=ProjectedCharacteristicAlias )? ;
	public ExplicitSelectedEntityCharacteristicReferenceElements getExplicitSelectedEntityCharacteristicReferenceAccess() {
		return pExplicitSelectedEntityCharacteristicReference;
	}
	
	public ParserRule getExplicitSelectedEntityCharacteristicReferenceRule() {
		return getExplicitSelectedEntityCharacteristicReferenceAccess().getRule();
	}
	
	///**
	//A SelectedEntityExpression defines the context for a QueryStatement's data set as a set of related Entities (using the FromClause). It may also specify a set of conditions expressed over Characteristics of those Entities that are true for all data in the data set (using a WhereClause) and specify how data in the data set is ordered (using an OrderByClause).
	//*/
	//SelectedEntityExpression : from=FromClause  ( where=WhereClause )?  ( orderBy=OrderByClause )? ;
	public SelectedEntityExpressionElements getSelectedEntityExpressionAccess() {
		return pSelectedEntityExpression;
	}
	
	public ParserRule getSelectedEntityExpressionRule() {
		return getSelectedEntityExpressionAccess().getRule();
	}
	
	///**
	//A FromClause identifies a set of related Entities via EntityExpression.
	//*/
	//FromClause : 'from'  entity=EntityExpression ;
	public FromClauseElements getFromClauseAccess() {
		return pFromClause;
	}
	
	public ParserRule getFromClauseRule() {
		return getFromClauseAccess().getRule();
	}
	
	///**
	//An EntityExpression identifies a set of Entities and a set of relationships between those Entities. The set of Entities are the selected_entitys in the EntityExpression. The set of relationships are identified by the entity_type_characteristic_equivalence_expressions in the EntityExpression.
	//*/
	////EntityExpression : selectedEntity=SelectedEntity , { EntityJoinExpression } ;
	//EntityExpression : selectedEntity=SelectedEntity  (eje+=EntityJoinExpression)*  ;
	public EntityExpressionElements getEntityExpressionAccess() {
		return pEntityExpression;
	}
	
	public ParserRule getEntityExpressionRule() {
		return getEntityExpressionAccess().getRule();
	}
	
	///**
	//A SelectedEntity is the Entity whose name is EntityTypeReference. SelectedEntityAlias specifies an alias for the Entity for use elsewhere in a QueryStatement.
	//*/
	//SelectedEntity : entityType=EntityTypeReference  ( ( KW_AS )?  selectedEntityAlias=SelectedEntityAlias )? ;
	public SelectedEntityElements getSelectedEntityAccess() {
		return pSelectedEntity;
	}
	
	public ParserRule getSelectedEntityRule() {
		return getSelectedEntityAccess().getRule();
	}
	
	///**
	//    An EntityJoinExpression identifies an Entity (JoinEntity) and one or more relationships between it and other selected_entitys in the EntityExpression. Each relationship is identified with an EntityTypeCharacteristicEquivalenceExpression whose SelectedEntityCharacteristicReference is either a Characteristic of JoinEntity whose type is another SelectedEntity, or is a Characteristic of another SelectedEntity whose type is JoinEntity.
	//*/
	//EntityJoinExpression : KW_JOIN  joinEntity=JoinEntity  KW_ON  entityJoinCriteria=EntityJoinCriteria ;
	public EntityJoinExpressionElements getEntityJoinExpressionAccess() {
		return pEntityJoinExpression;
	}
	
	public ParserRule getEntityJoinExpressionRule() {
		return getEntityJoinExpressionAccess().getRule();
	}
	
	///**
	//A JoinEntity is a SelectedEntity in an EntityJoinExpression.
	//*/
	//JoinEntity : SelectedEntity ;
	public JoinEntityElements getJoinEntityAccess() {
		return pJoinEntity;
	}
	
	public ParserRule getJoinEntityRule() {
		return getJoinEntityAccess().getRule();
	}
	
	///**
	//An EntityJoinCriteria identifies one or more relationships between two or more selected_entitys in the EntityExpression. Each EntityTypeCharacteristicEquivalenceExpression identifies a relationship between two selected_entitys.
	//*/
	//EntityJoinCriteria : etcee+=EntityTypeCharacteristicEquivalenceExpression  ( KW_AND  etcee+=EntityTypeCharacteristicEquivalenceExpression )* ;
	public EntityJoinCriteriaElements getEntityJoinCriteriaAccess() {
		return pEntityJoinCriteria;
	}
	
	public ParserRule getEntityJoinCriteriaRule() {
		return getEntityJoinCriteriaAccess().getRule();
	}
	
	///**
	//An EntityTypeCharacteristicEquivalenceExpression identifies a relationship between two selected_entitys. SelectedEntityCharacteristicReference is a Characteristic of one SelectedEntity whose type is the another SelectedEntity in the EntityExpression. A SelectedEntityReference is used to identify a specific SelectedEntity should there be more than one SelectedEntity whose type is that Characteristic's type.
	//*/
	//EntityTypeCharacteristicEquivalenceExpression : secr=SelectedEntityCharacteristicReference  ( EQUALS_OPERATOR  selectedEntity=SelectedEntityReference )? ;
	public EntityTypeCharacteristicEquivalenceExpressionElements getEntityTypeCharacteristicEquivalenceExpressionAccess() {
		return pEntityTypeCharacteristicEquivalenceExpression;
	}
	
	public ParserRule getEntityTypeCharacteristicEquivalenceExpressionRule() {
		return getEntityTypeCharacteristicEquivalenceExpressionAccess().getRule();
	}
	
	///**
	//A SelectedEntityCharacteristicReference is a SelectedEntity's Characteristic specified by CharacteristicReference.
	//A SelectedEntityReference is used to identify a specific SelectedEntity should there be more than one Characteristic
	//whose name is CharacteristicReference.
	//*/
	//SelectedEntityCharacteristicReference : ( selectedEntity=SelectedEntityReference  PERIOD )?  characteristic=CharacteristicReference ;
	public SelectedEntityCharacteristicReferenceElements getSelectedEntityCharacteristicReferenceAccess() {
		return pSelectedEntityCharacteristicReference;
	}
	
	public ParserRule getSelectedEntityCharacteristicReferenceRule() {
		return getSelectedEntityCharacteristicReferenceAccess().getRule();
	}
	
	///**
	//A SelectedEntityReference is a reference by name to a SelectedEntity, where QueryIdentifier is either a SelectedEntity's
	//EntityTypeReference or its SelectedEntityAlias.
	//*/
	//SelectedEntityReference : QueryIdentifier ;
	public SelectedEntityReferenceElements getSelectedEntityReferenceAccess() {
		return pSelectedEntityReference;
	}
	
	public ParserRule getSelectedEntityReferenceRule() {
		return getSelectedEntityReferenceAccess().getRule();
	}
	
	///**
	//A WhereClause specifies a set of conditions that are true for all data in the QueryStatement's data set.
	//*/
	//WhereClause : KW_WHERE  criteria=Criteria ;
	public WhereClauseElements getWhereClauseAccess() {
		return pWhereClause;
	}
	
	public ParserRule getWhereClauseRule() {
		return getWhereClauseAccess().getRule();
	}
	
	///**
	//A Criteria specifies a set of conditions expressed over Characteristics of selected_entitys via BooleanExpression.
	//*/
	//Criteria : BooleanExpression ;
	public CriteriaElements getCriteriaAccess() {
		return pCriteria;
	}
	
	public ParserRule getCriteriaRule() {
		return getCriteriaAccess().getRule();
	}
	
	///**
	//An OrderByClause specifies how data in the QueryStatement's data set is ordered. The data set is initially ordered by the first OrderingExpression's ProjectedCharacteristicReference. Each additional OrderingExpression further orders the data set.
	//*/
	//OrderByClause : KW_ORDER  KW_BY  orderingExpression+=OrderingExpression  ( COMMA  orderingExpression+=OrderingExpression )* ;
	public OrderByClauseElements getOrderByClauseAccess() {
		return pOrderByClause;
	}
	
	public ParserRule getOrderByClauseRule() {
		return getOrderByClauseAccess().getRule();
	}
	
	///**
	//An OrderingExpression specifies a Characteristic in the ProjectedCharacteristicList used to order data in the QueryStatement's data set. If OrderingType DESC is specified, it indicates that data is ordered descending. Otherwise, it is ordered ascending.
	//*/
	//OrderingExpression : characteristic=ProjectedCharacteristicReference  (orderingType=OrderingType)? ;
	public OrderingExpressionElements getOrderingExpressionAccess() {
		return pOrderingExpression;
	}
	
	public ParserRule getOrderingExpressionRule() {
		return getOrderingExpressionAccess().getRule();
	}
	
	///**
	//A ProjectedCharacteristicReference is a reference to a Characteristic in the ProjectedCharacteristicList.
	//*/
	//ProjectedCharacteristicReference : QualifiedProjectedCharacteristicReference |  UnqualifiedProjectedCharacteristicReferenceOrAlias ;
	public ProjectedCharacteristicReferenceElements getProjectedCharacteristicReferenceAccess() {
		return pProjectedCharacteristicReference;
	}
	
	public ParserRule getProjectedCharacteristicReferenceRule() {
		return getProjectedCharacteristicReferenceAccess().getRule();
	}
	
	///**
	//A QualifiedProjectedCharacteristicReference is a Characteristic specified by CharacteristicReference in the Entity specified by SelectedEntityReference.
	//*/
	//QualifiedProjectedCharacteristicReference : selectedEntityReference=SelectedEntityReference PERIOD  characteristic=CharacteristicReference ;
	public QualifiedProjectedCharacteristicReferenceElements getQualifiedProjectedCharacteristicReferenceAccess() {
		return pQualifiedProjectedCharacteristicReference;
	}
	
	public ParserRule getQualifiedProjectedCharacteristicReferenceRule() {
		return getQualifiedProjectedCharacteristicReferenceAccess().getRule();
	}
	
	///**
	//An UnqualifiedProjectedCharacteristicReferenceOrAlias is a Characteristic in ProjectedCharacteristicList whose rolename
	//or assigned ProjectedCharacteristicAlias is QueryIdentifier. If QueryIdentifier happens to match both a
	//ProjectedCharacteristicAlias and a rolename, then the Characteristic associated with the ProjectedCharacteristicAlias
	//is assumed.
	//*/
	//UnqualifiedProjectedCharacteristicReferenceOrAlias : QueryIdentifier ;
	public UnqualifiedProjectedCharacteristicReferenceOrAliasElements getUnqualifiedProjectedCharacteristicReferenceOrAliasAccess() {
		return pUnqualifiedProjectedCharacteristicReferenceOrAlias;
	}
	
	public ParserRule getUnqualifiedProjectedCharacteristicReferenceOrAliasRule() {
		return getUnqualifiedProjectedCharacteristicReferenceOrAliasAccess().getRule();
	}
	
	///**
	//An OrderingType specifies whether data is ordered ascending (KW_ASC) or descending (KW_DESC).
	//*/
	//OrderingType : KW_ASC | KW_DESC ;
	public OrderingTypeElements getOrderingTypeAccess() {
		return pOrderingType;
	}
	
	public ParserRule getOrderingTypeRule() {
		return getOrderingTypeAccess().getRule();
	}
	
	///**
	// * Boolean expressions are left recursive. To address this, see the book p 169
	// */
	///**
	//A BooleanExpression is a boolean OR expression over boolean_terms.
	//*/
	//BooleanExpression : term+=BooleanTerm  ( KW_OR  term+=BooleanTerm )* ;
	public BooleanExpressionElements getBooleanExpressionAccess() {
		return pBooleanExpression;
	}
	
	public ParserRule getBooleanExpressionRule() {
		return getBooleanExpressionAccess().getRule();
	}
	
	///**
	//A BooleanTerm is a boolean AND expression over boolean_factors.
	//*/
	//BooleanTerm : factor+=BooleanFactor  ( KW_AND  factor+=BooleanFactor )* ;
	public BooleanTermElements getBooleanTermAccess() {
		return pBooleanTerm;
	}
	
	public ParserRule getBooleanTermRule() {
		return getBooleanTermAccess().getRule();
	}
	
	///**
	//A BooleanFactor is a BooleanPredicate. If KW_NOT is not present, it evaluates the same as BooleanPredicate. If KW_NOT is present, the evaluation is the same but negated.
	//*/
	//BooleanFactor :  (not?=KW_NOT)?  pred=BooleanPredicate ;
	public BooleanFactorElements getBooleanFactorAccess() {
		return pBooleanFactor;
	}
	
	public ParserRule getBooleanFactorRule() {
		return getBooleanFactorAccess().getRule();
	}
	
	///**
	// * NOTE: The problem with BooleanPredicate is when more than one of     ScalarComparePredicate | SetComparePredicate | SetMembershipPredicate  is uncommented.
	// * This results in a non LL grammar. Search for syntactic predicates in the book.
	// *
	// * TODO: fix this when we need set membership or set comparison capability
	// */
	///**
	//A BooleanPredicate is a predicate.
	//*/
	//BooleanPredicate :
	//    ScalarComparePredicate |
	////    SetComparePredicate |
	////    SetMembershipPredicate |
	//    ExistsPredicate |
	//    LEFT_PAREN  BooleanExpression  RIGHT_PAREN
	//;
	public BooleanPredicateElements getBooleanPredicateAccess() {
		return pBooleanPredicate;
	}
	
	public ParserRule getBooleanPredicateRule() {
		return getBooleanPredicateAccess().getRule();
	}
	
	///**
	//A ScalarComparePredicate is a function that compares two PredicateTerms. It evaluates to TRUE if the comparison is true, FALSE otherwise.
	//*/
	//ScalarComparePredicate : left=PredicateTerm op=CompareOperator right=PredicateTerm ;
	public ScalarComparePredicateElements getScalarComparePredicateAccess() {
		return pScalarComparePredicate;
	}
	
	public ParserRule getScalarComparePredicateRule() {
		return getScalarComparePredicateAccess().getRule();
	}
	
	///**
	//A SetMembershipPredicate is a function that checks a PredicateTerm for membership in a LogicalSet. If KW_NOT is not present, it evaluates to TRUE if PredicateTerm is a member of LogicalSet, FALSE otherwise. If KW_NOT is present, the evaluation is the same but negated.
	//*/
	//SetMembershipPredicate : left=PredicateTerm  ( not?=KW_NOT)?  KW_IN  set=LogicalSet ;
	public SetMembershipPredicateElements getSetMembershipPredicateAccess() {
		return pSetMembershipPredicate;
	}
	
	public ParserRule getSetMembershipPredicateRule() {
		return getSetMembershipPredicateAccess().getRule();
	}
	
	///**
	//A LogicalSet is a set of data. If LogicalSet is a Subquery with one Characteristic in its ProjectedCharacteristicList, the set is the data associated with that Characteristic. If LogicalSet is a CharacteristicBasisSet, the set is the data associated with each CharacteristicBasis. If LogicalSet is an EnumLiteralSet, the set is the specified EnumerationLabels.
	//*/
	//LogicalSet : Subquery | CharacteristicBasisSet | EnumLiteralSet ;
	public LogicalSetElements getLogicalSetAccess() {
		return pLogicalSet;
	}
	
	public ParserRule getLogicalSetRule() {
		return getLogicalSetAccess().getRule();
	}
	
	///**
	//A CharacteristicBasisSet is one or more CharacteristicBasis.
	//*/
	//CharacteristicBasisSet : LEFT_PAREN  characteristicBasis+=CharacteristicBasis  ( COMMA  characteristicBasis+=CharacteristicBasis)*  RIGHT_PAREN ;
	public CharacteristicBasisSetElements getCharacteristicBasisSetAccess() {
		return pCharacteristicBasisSet;
	}
	
	public ParserRule getCharacteristicBasisSetRule() {
		return getCharacteristicBasisSetAccess().getRule();
	}
	
	///**
	//A SetComparePredicate is a function that represents a pair-wise comparison of PredicateTerm with all members of CompareSet.
	//If SetCompareQuantifier is KW_ALL, the function evaluates to TRUE if the application of CompareOperator evaluates to TRUE
	//for PredicateTerm and every member of the set, FALSE otherwise. If SetCompareQuantifier is KW_SOME, the function evaluates to
	//TRUE if the application of CompareOperator evaluates to TRUE for PredicateTerm and at least one member in the set, FALSE otherwise.
	//*/
	//SetComparePredicate : pred=PredicateTerm  op=CompareOperator quantifier=SetCompareQuantifier set=CompareSet ;
	public SetComparePredicateElements getSetComparePredicateAccess() {
		return pSetComparePredicate;
	}
	
	public ParserRule getSetComparePredicateRule() {
		return getSetComparePredicateAccess().getRule();
	}
	
	///**
	//A CompareSet is a Subquery with a single Characteristic in its ProjectedCharacteristicList.
	//*/
	//CompareSet : Subquery ;
	public CompareSetElements getCompareSetAccess() {
		return pCompareSet;
	}
	
	public ParserRule getCompareSetRule() {
		return getCompareSetAccess().getRule();
	}
	
	///**
	//A CompareOperator is a boolean comparison operator.
	//*/
	//CompareOperator : EQUALS_OPERATOR | NOT_EQUALS_OPERATOR |
	//                  LESS_THAN_OPERATOR | GREATER_THAN_OPERATOR | LESS_THAN_OR_EQUALS_OPERATOR | GREATER_THAN_OR_EQUALS_OPERATOR
	//;
	public CompareOperatorElements getCompareOperatorAccess() {
		return pCompareOperator;
	}
	
	public ParserRule getCompareOperatorRule() {
		return getCompareOperatorAccess().getRule();
	}
	
	///**
	//A SetCompareQuantifier indicates that a comparison applies to every (KW_ALL) or any (KW_SOME) member of a set.
	//*/
	//SetCompareQuantifier : KW_ALL | KW_SOME ;
	public SetCompareQuantifierElements getSetCompareQuantifierAccess() {
		return pSetCompareQuantifier;
	}
	
	public ParserRule getSetCompareQuantifierRule() {
		return getSetCompareQuantifierAccess().getRule();
	}
	
	///**
	//An ExistsPredicate is a function that evaluates to TRUE if there is any data associated with the single Characteristic in Subquery's ProjectedCharacteristicList, FALSE otherwise.
	//*/
	//ExistsPredicate : KW_EXISTS  sub=Subquery ;
	public ExistsPredicateElements getExistsPredicateAccess() {
		return pExistsPredicate;
	}
	
	public ParserRule getExistsPredicateRule() {
		return getExistsPredicateAccess().getRule();
	}
	
	///**
	//A PredicateTerm represents a DataModel Element whose associated data is scalar.
	//*/
	//PredicateTerm : CharacteristicBasis | EnumLiteralReferenceExpression ;
	public PredicateTermElements getPredicateTermAccess() {
		return pPredicateTerm;
	}
	
	public ParserRule getPredicateTermRule() {
		return getPredicateTermAccess().getRule();
	}
	
	///**
	//A CharacteristicBasis is a Characteristic whose associated data is scalar. If CharacteristicBasis is a
	//Subquery with one Characteristic in its ProjectedCharacteristicList, then the CharacteristicBasis is that Characteristic.
	//Otherwise, the Characteristic is specified by SelectedEntityCharacteristicReference.
	//*/
	//CharacteristicBasis : SelectedEntityCharacteristicReference | Subquery ;
	public CharacteristicBasisElements getCharacteristicBasisAccess() {
		return pCharacteristicBasis;
	}
	
	public ParserRule getCharacteristicBasisRule() {
		return getCharacteristicBasisAccess().getRule();
	}
	
	///**
	//A Subquery is a QueryStatement that is nested inside another QueryStatement.
	//*/
	//Subquery : LEFT_PAREN  query=QueryStatement  RIGHT_PAREN ;
	public SubqueryElements getSubqueryAccess() {
		return pSubquery;
	}
	
	public ParserRule getSubqueryRule() {
		return getSubqueryAccess().getRule();
	}
	
	///**
	//A CharacteristicReference is a Characteristic whose rolename matches QueryIdentifier.
	//*/
	//CharacteristicReference : QueryIdentifier ;
	public CharacteristicReferenceElements getCharacteristicReferenceAccess() {
		return pCharacteristicReference;
	}
	
	public ParserRule getCharacteristicReferenceRule() {
		return getCharacteristicReferenceAccess().getRule();
	}
	
	///**
	//An EntityTypeReference is the Entity whose name matches QueryIdentifier.
	//*/
	//EntityTypeReference : QueryIdentifier ;
	public EntityTypeReferenceElements getEntityTypeReferenceAccess() {
		return pEntityTypeReference;
	}
	
	public ParserRule getEntityTypeReferenceRule() {
		return getEntityTypeReferenceAccess().getRule();
	}
	
	///**
	//An EnumLiteralSet is a set of EnumerationLabels. Each member in the set is identified by the EnumerationLabel whose name is EnumerationLiteralReference in the Enumerated whose name is EnumerationTypeReference.
	//*/
	//EnumLiteralSet : LEFT_BRACE type=EnumerationTypeReference COLON  literal+=EnumerationLiteralReference  ( COMMA  literal+=EnumerationLiteralReference )* RIGHT_BRACE ;
	public EnumLiteralSetElements getEnumLiteralSetAccess() {
		return pEnumLiteralSet;
	}
	
	public ParserRule getEnumLiteralSetRule() {
		return getEnumLiteralSetAccess().getRule();
	}
	
	///**
	//An EnumLiteralReferenceExpression is an EnumerationLabel whose name is EnumerationLiteralReference in the Enumerated whose name is EnumerationTypeReference.
	//*/
	//EnumLiteralReferenceExpression : LEFT_BRACE  typ=EnumerationTypeReference  COLON  literal=EnumerationLiteralReference RIGHT_BRACE ;
	public EnumLiteralReferenceExpressionElements getEnumLiteralReferenceExpressionAccess() {
		return pEnumLiteralReferenceExpression;
	}
	
	public ParserRule getEnumLiteralReferenceExpressionRule() {
		return getEnumLiteralReferenceExpressionAccess().getRule();
	}
	
	///**
	//An EnumerationTypeReference is the Enumerated whose name matches QueryIdentifier.
	//*/
	//EnumerationTypeReference : QueryIdentifier ;
	public EnumerationTypeReferenceElements getEnumerationTypeReferenceAccess() {
		return pEnumerationTypeReference;
	}
	
	public ParserRule getEnumerationTypeReferenceRule() {
		return getEnumerationTypeReferenceAccess().getRule();
	}
	
	///**
	//An EnumerationLiteralReference is an EnumerationLabel whose name matches QueryIdentifier.
	//*/
	//EnumerationLiteralReference : QueryIdentifier ;
	public EnumerationLiteralReferenceElements getEnumerationLiteralReferenceAccess() {
		return pEnumerationLiteralReference;
	}
	
	public ParserRule getEnumerationLiteralReferenceRule() {
		return getEnumerationLiteralReferenceAccess().getRule();
	}
	
	///**
	//A SelectedEntityAlias is an alias for a SelectedEntity.
	//*/
	//SelectedEntityAlias : QueryIdentifier ;
	public SelectedEntityAliasElements getSelectedEntityAliasAccess() {
		return pSelectedEntityAlias;
	}
	
	public ParserRule getSelectedEntityAliasRule() {
		return getSelectedEntityAliasAccess().getRule();
	}
	
	///**
	//A ProjectedCharacteristicAlias provides an alias for a Characteristic in a ProjectedCharacteristicList.
	//*/
	//ProjectedCharacteristicAlias : QueryIdentifier ;
	public ProjectedCharacteristicAliasElements getProjectedCharacteristicAliasAccess() {
		return pProjectedCharacteristicAlias;
	}
	
	public ParserRule getProjectedCharacteristicAliasRule() {
		return getProjectedCharacteristicAliasAccess().getRule();
	}
	
	///**
	//A QueryIdentifier is an alphanumeric string used to represent an Identifier in a QuerySpecification.
	//*/
	//QueryIdentifier : id=IDENTIFIER ;
	public QueryIdentifierElements getQueryIdentifierAccess() {
		return pQueryIdentifier;
	}
	
	public ParserRule getQueryIdentifierRule() {
		return getQueryIdentifierAccess().getRule();
	}
	
	// // ID ; // These are identical - and if they aren't, they should be
	///**
	//* The following terms start with kw_ to indicate that they are keyword tokens.
	//* Note that some rules have been modified to recognize any mix of case.
	//* TODO: Is this desirable? Either all should be this way, or none. When we start using this grammar to edit the queries
	//* this will become obvious.
	//*/
	//terminal KW_ALL : ('A'|'a')('L'|'l')('L'|'l');
	public TerminalRule getKW_ALLRule() {
		return tKW_ALL;
	}
	
	// // "ALL" | "all" ;
	//terminal KW_SOME : ('S'|'s')('O'|'o')('M'|'m')('E'|'e') | ('A'|'a')('N'|'n')('Y'|'y');
	public TerminalRule getKW_SOMERule() {
		return tKW_SOME;
	}
	
	// //  "SOME" | "some" | "ANY" | "any" ;
	//terminal KW_EXISTS : "EXISTS" | "exists" ;
	public TerminalRule getKW_EXISTSRule() {
		return tKW_EXISTS;
	}
	
	//terminal KW_NOT : "NOT" | "not" ;
	public TerminalRule getKW_NOTRule() {
		return tKW_NOT;
	}
	
	//terminal KW_IN : "IN" | "in" ;
	public TerminalRule getKW_INRule() {
		return tKW_IN;
	}
	
	////terminal KW_SELECT :  "SELECT" | "select"; // | //('S'|'s')('E'|'e')('L'|'l')('E'|'e')('C'|'c')('T'|'t');
	//terminal KW_AND : "AND" | "and" ;
	public TerminalRule getKW_ANDRule() {
		return tKW_AND;
	}
	
	//terminal KW_OR : "OR" | "or" ;
	public TerminalRule getKW_ORRule() {
		return tKW_OR;
	}
	
	//terminal KW_AS : "AS" | "as" ;
	public TerminalRule getKW_ASRule() {
		return tKW_AS;
	}
	
	//terminal KW_DISTINCT : "DISTINCT" | "distinct" ;
	public TerminalRule getKW_DISTINCTRule() {
		return tKW_DISTINCT;
	}
	
	////terminal KW_FROM : "FROM" | "from" ;
	//terminal KW_WHERE : "WHERE" | "where" ;
	public TerminalRule getKW_WHERERule() {
		return tKW_WHERE;
	}
	
	//terminal KW_BY : "BY" | "by" ;
	public TerminalRule getKW_BYRule() {
		return tKW_BY;
	}
	
	//terminal KW_JOIN : "JOIN" | "join" ;
	public TerminalRule getKW_JOINRule() {
		return tKW_JOIN;
	}
	
	//terminal KW_ON : "ON" | "on" ;
	public TerminalRule getKW_ONRule() {
		return tKW_ON;
	}
	
	//terminal KW_ORDER : "ORDER" | "order" ;
	public TerminalRule getKW_ORDERRule() {
		return tKW_ORDER;
	}
	
	//terminal KW_ASC : "ASC" | "asc" ;
	public TerminalRule getKW_ASCRule() {
		return tKW_ASC;
	}
	
	//terminal KW_DESC : "DESC" | "desc" ;
	public TerminalRule getKW_DESCRule() {
		return tKW_DESC;
	}
	
	///**
	//The following terms represent boolean operator tokens.
	//*/
	///**
	//An EQUALS_OPERATOR is the boolean equals operator.
	//*/
	//terminal EQUALS_OPERATOR : "=" ;
	public TerminalRule getEQUALS_OPERATORRule() {
		return tEQUALS_OPERATOR;
	}
	
	///**
	//A NOT_EQUALS_OPERATOR is the boolean not equals operator.
	//*/
	//terminal NOT_EQUALS_OPERATOR : "<>" | "!:" ;
	public TerminalRule getNOT_EQUALS_OPERATORRule() {
		return tNOT_EQUALS_OPERATOR;
	}
	
	///**
	//A LESS_THAN_OPERATOR is the boolean less-than operator.
	//*/
	//terminal LESS_THAN_OPERATOR : "<" ;
	public TerminalRule getLESS_THAN_OPERATORRule() {
		return tLESS_THAN_OPERATOR;
	}
	
	///**
	//A GREATER_THAN_OPERATOR is the boolean greater-than operator.
	//*/
	//terminal GREATER_THAN_OPERATOR : ">" ;
	public TerminalRule getGREATER_THAN_OPERATORRule() {
		return tGREATER_THAN_OPERATOR;
	}
	
	///**
	//A GREATER_THAN_OR_EQUALS_OPERATOR is the boolean greater-than-or-equals operator.
	//*/
	//terminal GREATER_THAN_OR_EQUALS_OPERATOR : ">:" ;
	public TerminalRule getGREATER_THAN_OR_EQUALS_OPERATORRule() {
		return tGREATER_THAN_OR_EQUALS_OPERATOR;
	}
	
	///**
	//A LESS_THAN_OR_EQUALS_OPERATOR is the boolean less-than-or-equals operator.
	//*/
	//terminal LESS_THAN_OR_EQUALS_OPERATOR : "<:" ;
	public TerminalRule getLESS_THAN_OR_EQUALS_OPERATORRule() {
		return tLESS_THAN_OR_EQUALS_OPERATOR;
	}
	
	///**
	//The following terms represent punctuation tokens.
	//*/
	//terminal COMMA : "," ;
	public TerminalRule getCOMMARule() {
		return tCOMMA;
	}
	
	//terminal LEFT_PAREN : "(" ;
	public TerminalRule getLEFT_PARENRule() {
		return tLEFT_PAREN;
	}
	
	//terminal RIGHT_PAREN : ")" ;
	public TerminalRule getRIGHT_PARENRule() {
		return tRIGHT_PAREN;
	}
	
	//terminal PERIOD : "." ;
	public TerminalRule getPERIODRule() {
		return tPERIOD;
	}
	
	//terminal LEFT_BRACE : "{" ;
	public TerminalRule getLEFT_BRACERule() {
		return tLEFT_BRACE;
	}
	
	//terminal RIGHT_BRACE : "}" ;
	public TerminalRule getRIGHT_BRACERule() {
		return tRIGHT_BRACE;
	}
	
	//terminal COLON : ":" ;
	public TerminalRule getCOLONRule() {
		return tCOLON;
	}
	
	///**
	//The following terms represent Identifier tokens.
	//*/
	//terminal IDENTIFIER : LETTER  ( LETTER | DIGITAL_LITERAL)* ;
	public TerminalRule getIDENTIFIERRule() {
		return tIDENTIFIER;
	}
	
	//terminal LETTER : "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" | "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" | "u" | "v" | "w" | "x" | "y" | "z" | "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" | "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" | "U" | "V" | "W" | "X" | "Y" | "Z" | "_" ;
	public TerminalRule getLETTERRule() {
		return tLETTER;
	}
	
	//terminal DIGITAL_LITERAL : "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
	public TerminalRule getDIGITAL_LITERALRule() {
		return tDIGITAL_LITERAL;
	}
	
	//terminal ID: '^'?('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*;
	public TerminalRule getIDRule() {
		return gaTerminals.getIDRule();
	}
	
	//terminal INT returns ecore::EInt: ('0'..'9')+;
	public TerminalRule getINTRule() {
		return gaTerminals.getINTRule();
	}
	
	//terminal STRING:
	//            '"' ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|'"') )* '"' |
	//            "'" ( '\\' . /* 'b'|'t'|'n'|'f'|'r'|'u'|'"'|"'"|'\\' */ | !('\\'|"'") )* "'"
	//        ;
	public TerminalRule getSTRINGRule() {
		return gaTerminals.getSTRINGRule();
	}
	
	//terminal ML_COMMENT : '/*' -> '*/';
	public TerminalRule getML_COMMENTRule() {
		return gaTerminals.getML_COMMENTRule();
	}
	
	//terminal SL_COMMENT : '//' !('\n'|'\r')* ('\r'? '\n')?;
	public TerminalRule getSL_COMMENTRule() {
		return gaTerminals.getSL_COMMENTRule();
	}
	
	//terminal WS         : (' '|'\t'|'\r'|'\n')+;
	public TerminalRule getWSRule() {
		return gaTerminals.getWSRule();
	}
	
	//terminal ANY_OTHER: .;
	public TerminalRule getANY_OTHERRule() {
		return gaTerminals.getANY_OTHERRule();
	}
}

/**
 * generated by Xtext 2.32.0
 */
package com.epistimis.uddl.query.tests;

import com.epistimis.uddl.query.query.QuerySpecification;
import com.google.inject.Inject;
import org.eclipse.emf.common.util.EList;
import org.eclipse.emf.ecore.resource.Resource;
import org.eclipse.xtend2.lib.StringConcatenation;
import org.eclipse.xtext.testing.InjectWith;
import org.eclipse.xtext.testing.extensions.InjectionExtension;
import org.eclipse.xtext.testing.util.ParseHelper;
import org.eclipse.xtext.xbase.lib.Exceptions;
import org.eclipse.xtext.xbase.lib.IterableExtensions;
import org.junit.jupiter.api.Assertions;
import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;

/**
 * TODO: There is a weird parsing bug here. Change any field name to '.desc' and it will cause that test to fail.
 * Is that because it is interpreting that as an escape?
 */
@ExtendWith(InjectionExtension.class)
@InjectWith(QueryInjectorProvider.class)
@SuppressWarnings("all")
public class QueryParsingTest {
  @Inject
  private ParseHelper<QuerySpecification> parseHelper;

  @Test
  public void testBasicSelect() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select * from X");
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  /**
   * This test fails consistently when 'x.desd' or 'x.description' is converted to 'x.desc'.
   * Is it a problem with encoding? or with the '.desc' being parsed as escape??
   */
  @Test
  public void testRIG_EquivalentEntity_Query1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select x.id, x.description from X as x");
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_EquivalentEntity_Query2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select p.mass, p.vol from P as p");
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_AircraftAirportArrival_PDM_Query1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select Airport.ID, Airport.code, Gate.ID, Gate.capacity from Airport join Gate on Airport.gates;");
      _builder.newLine();
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_ModeledDomainConcepts_PDM_Query1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select position, extents as size from Area as aoi");
      _builder.newLine();
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_DogOwnership_CDM_Query1() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select name from Dog");
      _builder.newLine();
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_DogOwnership_CDM_Query2() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("select Person.*, Dog.* from Person join DogOwnership on DogOwnership.owner = Person join Dog on DogOwnership.dog = Dog");
      _builder.newLine();
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }

  @Test
  public void testRIG_DogOwnership_CDM_Query3() {
    try {
      StringConcatenation _builder = new StringConcatenation();
      _builder.append("SELECT Person.*, Dog.name, Dog.age, DogOwnership.* FROM Person JOIN DogOwnership on DogOwnership.owner = Person JOIN Dog on DogOwnership.dog = Dog");
      _builder.newLine();
      final QuerySpecification result = this.parseHelper.parse(_builder);
      Assertions.assertNotNull(result);
      final EList<Resource.Diagnostic> errors = result.eResource().getErrors();
      boolean _isEmpty = errors.isEmpty();
      StringConcatenation _builder_1 = new StringConcatenation();
      _builder_1.append("Unexpected errors: ");
      String _join = IterableExtensions.join(errors, ", ");
      _builder_1.append(_join);
      Assertions.assertTrue(_isEmpty, _builder_1.toString());
    } catch (Throwable _e) {
      throw Exceptions.sneakyThrow(_e);
    }
  }
}
